/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ActionsApiService ActionsApi service
type ActionsApiService service

type ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
	enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest *EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
}

func (r ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest) EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest(enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest) ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest {
	r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest = &enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
	return r
}

func (r ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsAddCustomLabelsToSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsAddCustomLabelsToSelfHostedRunnerForOrg Add custom labels to a self-hosted runner for an organization

Add custom labels to a self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsAddCustomLabelsToSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32) ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest {
	return ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsAddCustomLabelsToSelfHostedRunnerForOrgExecute(r ApiActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsAddCustomLabelsToSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest == nil {
		return localVarReturnValue, nil, reportError("enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
	enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest *EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
}

func (r ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest) EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest(enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest) ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest {
	r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest = &enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
	return r
}

func (r ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsAddCustomLabelsToSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsAddCustomLabelsToSelfHostedRunnerForRepo Add custom labels to a self-hosted runner for a repository

Add custom labels to a self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsAddCustomLabelsToSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest {
	return ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsAddCustomLabelsToSelfHostedRunnerForRepoExecute(r ApiActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsAddCustomLabelsToSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest == nil {
		return localVarReturnValue, nil, reportError("enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	repositoryId int32
}

func (r ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgExecute(r)
}

/*
ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg Add repository access to a self-hosted runner group in an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Adds a repository to the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

You must authenticate using an access token with the `admin:org`
scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @param repositoryId The unique identifier of the repository.
 @return ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest
*/
func (a *ActionsApiService) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org string, runnerGroupId int32, repositoryId int32) ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	return ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgExecute(r ApiActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsAddSelectedRepoToOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
	repositoryId int32
}

func (r ApiActionsAddSelectedRepoToOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsAddSelectedRepoToOrgSecretExecute(r)
}

/*
ActionsAddSelectedRepoToOrgSecret Add selected repository to an organization secret

Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @param repositoryId
 @return ApiActionsAddSelectedRepoToOrgSecretRequest
*/
func (a *ActionsApiService) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, org string, secretName string, repositoryId int32) ApiActionsAddSelectedRepoToOrgSecretRequest {
	return ApiActionsAddSelectedRepoToOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsAddSelectedRepoToOrgSecretExecute(r ApiActionsAddSelectedRepoToOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsAddSelectedRepoToOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsAddSelfHostedRunnerToGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	runnerId int32
}

func (r ApiActionsAddSelfHostedRunnerToGroupForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsAddSelfHostedRunnerToGroupForOrgExecute(r)
}

/*
ActionsAddSelfHostedRunnerToGroupForOrg Add a self-hosted runner to a group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Adds a self-hosted runner to a runner group configured in an organization.

You must authenticate using an access token with the `admin:org`
scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsAddSelfHostedRunnerToGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsAddSelfHostedRunnerToGroupForOrg(ctx context.Context, org string, runnerGroupId int32, runnerId int32) ApiActionsAddSelfHostedRunnerToGroupForOrgRequest {
	return ApiActionsAddSelfHostedRunnerToGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
		runnerId: runnerId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsAddSelfHostedRunnerToGroupForOrgExecute(r ApiActionsAddSelfHostedRunnerToGroupForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsAddSelfHostedRunnerToGroupForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsApproveWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsApproveWorkflowRunRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsApproveWorkflowRunExecute(r)
}

/*
ActionsApproveWorkflowRun Approve a workflow run for a fork pull request

Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsApproveWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsApproveWorkflowRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsApproveWorkflowRunRequest {
	return ApiActionsApproveWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsApproveWorkflowRunExecute(r ApiActionsApproveWorkflowRunRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsApproveWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCancelWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsCancelWorkflowRunRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsCancelWorkflowRunExecute(r)
}

/*
ActionsCancelWorkflowRun Cancel a workflow run

Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsCancelWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsCancelWorkflowRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsCancelWorkflowRunRequest {
	return ApiActionsCancelWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsCancelWorkflowRunExecute(r ApiActionsCancelWorkflowRunRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCancelWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateOrUpdateEnvironmentSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	repositoryId int32
	environmentName string
	secretName string
	actionsCreateOrUpdateEnvironmentSecretRequest *ActionsCreateOrUpdateEnvironmentSecretRequest
}

func (r ApiActionsCreateOrUpdateEnvironmentSecretRequest) ActionsCreateOrUpdateEnvironmentSecretRequest(actionsCreateOrUpdateEnvironmentSecretRequest ActionsCreateOrUpdateEnvironmentSecretRequest) ApiActionsCreateOrUpdateEnvironmentSecretRequest {
	r.actionsCreateOrUpdateEnvironmentSecretRequest = &actionsCreateOrUpdateEnvironmentSecretRequest
	return r
}

func (r ApiActionsCreateOrUpdateEnvironmentSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsCreateOrUpdateEnvironmentSecretExecute(r)
}

/*
ActionsCreateOrUpdateEnvironmentSecret Create or update an environment secret

Creates or updates an environment secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryId The unique identifier of the repository.
 @param environmentName The name of the environment
 @param secretName The name of the secret.
 @return ApiActionsCreateOrUpdateEnvironmentSecretRequest
*/
func (a *ActionsApiService) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, repositoryId int32, environmentName string, secretName string) ApiActionsCreateOrUpdateEnvironmentSecretRequest {
	return ApiActionsCreateOrUpdateEnvironmentSecretRequest{
		ApiService: a,
		ctx: ctx,
		repositoryId: repositoryId,
		environmentName: environmentName,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsCreateOrUpdateEnvironmentSecretExecute(r ApiActionsCreateOrUpdateEnvironmentSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateOrUpdateEnvironmentSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_name"+"}", url.PathEscape(parameterToString(r.environmentName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsCreateOrUpdateEnvironmentSecretRequest == nil {
		return localVarReturnValue, nil, reportError("actionsCreateOrUpdateEnvironmentSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsCreateOrUpdateEnvironmentSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateOrUpdateOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
	actionsCreateOrUpdateOrgSecretRequest *ActionsCreateOrUpdateOrgSecretRequest
}

func (r ApiActionsCreateOrUpdateOrgSecretRequest) ActionsCreateOrUpdateOrgSecretRequest(actionsCreateOrUpdateOrgSecretRequest ActionsCreateOrUpdateOrgSecretRequest) ApiActionsCreateOrUpdateOrgSecretRequest {
	r.actionsCreateOrUpdateOrgSecretRequest = &actionsCreateOrUpdateOrgSecretRequest
	return r
}

func (r ApiActionsCreateOrUpdateOrgSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsCreateOrUpdateOrgSecretExecute(r)
}

/*
ActionsCreateOrUpdateOrgSecret Create or update an organization secret

Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to
use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsCreateOrUpdateOrgSecretRequest
*/
func (a *ActionsApiService) ActionsCreateOrUpdateOrgSecret(ctx context.Context, org string, secretName string) ApiActionsCreateOrUpdateOrgSecretRequest {
	return ApiActionsCreateOrUpdateOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsCreateOrUpdateOrgSecretExecute(r ApiActionsCreateOrUpdateOrgSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateOrUpdateOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsCreateOrUpdateOrgSecretRequest == nil {
		return localVarReturnValue, nil, reportError("actionsCreateOrUpdateOrgSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsCreateOrUpdateOrgSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateOrUpdateRepoSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	secretName string
	actionsCreateOrUpdateRepoSecretRequest *ActionsCreateOrUpdateRepoSecretRequest
}

func (r ApiActionsCreateOrUpdateRepoSecretRequest) ActionsCreateOrUpdateRepoSecretRequest(actionsCreateOrUpdateRepoSecretRequest ActionsCreateOrUpdateRepoSecretRequest) ApiActionsCreateOrUpdateRepoSecretRequest {
	r.actionsCreateOrUpdateRepoSecretRequest = &actionsCreateOrUpdateRepoSecretRequest
	return r
}

func (r ApiActionsCreateOrUpdateRepoSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsCreateOrUpdateRepoSecretExecute(r)
}

/*
ActionsCreateOrUpdateRepoSecret Create or update a repository secret

Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsCreateOrUpdateRepoSecretRequest
*/
func (a *ActionsApiService) ActionsCreateOrUpdateRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiActionsCreateOrUpdateRepoSecretRequest {
	return ApiActionsCreateOrUpdateRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsCreateOrUpdateRepoSecretExecute(r ApiActionsCreateOrUpdateRepoSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateOrUpdateRepoSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsCreateOrUpdateRepoSecretRequest == nil {
		return localVarReturnValue, nil, reportError("actionsCreateOrUpdateRepoSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsCreateOrUpdateRepoSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateRegistrationTokenForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsCreateRegistrationTokenForOrgRequest) Execute() (*AuthenticationToken, *http.Response, error) {
	return r.ApiService.ActionsCreateRegistrationTokenForOrgExecute(r)
}

/*
ActionsCreateRegistrationTokenForOrg Create a registration token for an organization

Returns a token that you can pass to the `config` script. The token expires after one hour.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

#### Example using registration token

Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.

```
./config.sh --url https://github.com/octo-org --token TOKEN
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsCreateRegistrationTokenForOrgRequest
*/
func (a *ActionsApiService) ActionsCreateRegistrationTokenForOrg(ctx context.Context, org string) ApiActionsCreateRegistrationTokenForOrgRequest {
	return ApiActionsCreateRegistrationTokenForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return AuthenticationToken
func (a *ActionsApiService) ActionsCreateRegistrationTokenForOrgExecute(r ApiActionsCreateRegistrationTokenForOrgRequest) (*AuthenticationToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateRegistrationTokenForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/registration-token"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateRegistrationTokenForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsCreateRegistrationTokenForRepoRequest) Execute() (*AuthenticationToken, *http.Response, error) {
	return r.ApiService.ActionsCreateRegistrationTokenForRepoExecute(r)
}

/*
ActionsCreateRegistrationTokenForRepo Create a registration token for a repository

Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
using an access token with the `repo` scope to use this endpoint.

#### Example using registration token
 
Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.

```
./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsCreateRegistrationTokenForRepoRequest
*/
func (a *ActionsApiService) ActionsCreateRegistrationTokenForRepo(ctx context.Context, owner string, repo string) ApiActionsCreateRegistrationTokenForRepoRequest {
	return ApiActionsCreateRegistrationTokenForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return AuthenticationToken
func (a *ActionsApiService) ActionsCreateRegistrationTokenForRepoExecute(r ApiActionsCreateRegistrationTokenForRepoRequest) (*AuthenticationToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateRegistrationTokenForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/registration-token"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateRemoveTokenForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsCreateRemoveTokenForOrgRequest) Execute() (*AuthenticationToken, *http.Response, error) {
	return r.ApiService.ActionsCreateRemoveTokenForOrgExecute(r)
}

/*
ActionsCreateRemoveTokenForOrg Create a remove token for an organization

Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

#### Example using remove token

To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
endpoint.

```
./config.sh remove --token TOKEN
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsCreateRemoveTokenForOrgRequest
*/
func (a *ActionsApiService) ActionsCreateRemoveTokenForOrg(ctx context.Context, org string) ApiActionsCreateRemoveTokenForOrgRequest {
	return ApiActionsCreateRemoveTokenForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return AuthenticationToken
func (a *ActionsApiService) ActionsCreateRemoveTokenForOrgExecute(r ApiActionsCreateRemoveTokenForOrgRequest) (*AuthenticationToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateRemoveTokenForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/remove-token"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateRemoveTokenForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsCreateRemoveTokenForRepoRequest) Execute() (*AuthenticationToken, *http.Response, error) {
	return r.ApiService.ActionsCreateRemoveTokenForRepoExecute(r)
}

/*
ActionsCreateRemoveTokenForRepo Create a remove token for a repository

Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
You must authenticate using an access token with the `repo` scope to use this endpoint.

#### Example using remove token
 
To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.

```
./config.sh remove --token TOKEN
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsCreateRemoveTokenForRepoRequest
*/
func (a *ActionsApiService) ActionsCreateRemoveTokenForRepo(ctx context.Context, owner string, repo string) ApiActionsCreateRemoveTokenForRepoRequest {
	return ApiActionsCreateRemoveTokenForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return AuthenticationToken
func (a *ActionsApiService) ActionsCreateRemoveTokenForRepoExecute(r ApiActionsCreateRemoveTokenForRepoRequest) (*AuthenticationToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthenticationToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateRemoveTokenForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/remove-token"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateSelfHostedRunnerGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	actionsCreateSelfHostedRunnerGroupForOrgRequest *ActionsCreateSelfHostedRunnerGroupForOrgRequest
}

func (r ApiActionsCreateSelfHostedRunnerGroupForOrgRequest) ActionsCreateSelfHostedRunnerGroupForOrgRequest(actionsCreateSelfHostedRunnerGroupForOrgRequest ActionsCreateSelfHostedRunnerGroupForOrgRequest) ApiActionsCreateSelfHostedRunnerGroupForOrgRequest {
	r.actionsCreateSelfHostedRunnerGroupForOrgRequest = &actionsCreateSelfHostedRunnerGroupForOrgRequest
	return r
}

func (r ApiActionsCreateSelfHostedRunnerGroupForOrgRequest) Execute() (*RunnerGroupsOrg, *http.Response, error) {
	return r.ApiService.ActionsCreateSelfHostedRunnerGroupForOrgExecute(r)
}

/*
ActionsCreateSelfHostedRunnerGroupForOrg Create a self-hosted runner group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Creates a new self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsCreateSelfHostedRunnerGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsCreateSelfHostedRunnerGroupForOrg(ctx context.Context, org string) ApiActionsCreateSelfHostedRunnerGroupForOrgRequest {
	return ApiActionsCreateSelfHostedRunnerGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return RunnerGroupsOrg
func (a *ActionsApiService) ActionsCreateSelfHostedRunnerGroupForOrgExecute(r ApiActionsCreateSelfHostedRunnerGroupForOrgRequest) (*RunnerGroupsOrg, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RunnerGroupsOrg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateSelfHostedRunnerGroupForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsCreateSelfHostedRunnerGroupForOrgRequest == nil {
		return localVarReturnValue, nil, reportError("actionsCreateSelfHostedRunnerGroupForOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsCreateSelfHostedRunnerGroupForOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsCreateWorkflowDispatchRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
	actionsCreateWorkflowDispatchRequest *ActionsCreateWorkflowDispatchRequest
}

func (r ApiActionsCreateWorkflowDispatchRequest) ActionsCreateWorkflowDispatchRequest(actionsCreateWorkflowDispatchRequest ActionsCreateWorkflowDispatchRequest) ApiActionsCreateWorkflowDispatchRequest {
	r.actionsCreateWorkflowDispatchRequest = &actionsCreateWorkflowDispatchRequest
	return r
}

func (r ApiActionsCreateWorkflowDispatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsCreateWorkflowDispatchExecute(r)
}

/*
ActionsCreateWorkflowDispatch Create a workflow dispatch event

You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see "[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsCreateWorkflowDispatchRequest
*/
func (a *ActionsApiService) ActionsCreateWorkflowDispatch(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsCreateWorkflowDispatchRequest {
	return ApiActionsCreateWorkflowDispatchRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsCreateWorkflowDispatchExecute(r ApiActionsCreateWorkflowDispatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsCreateWorkflowDispatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsCreateWorkflowDispatchRequest == nil {
		return nil, reportError("actionsCreateWorkflowDispatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsCreateWorkflowDispatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteActionsCacheByIdRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	cacheId int32
}

func (r ApiActionsDeleteActionsCacheByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteActionsCacheByIdExecute(r)
}

/*
ActionsDeleteActionsCacheById Delete a GitHub Actions cache for a repository (using a cache ID)

Deletes a GitHub Actions cache for a repository, using a cache ID.

You must authenticate using an access token with the `repo` scope to use this endpoint.

GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param cacheId The unique identifier of the GitHub Actions cache.
 @return ApiActionsDeleteActionsCacheByIdRequest
*/
func (a *ActionsApiService) ActionsDeleteActionsCacheById(ctx context.Context, owner string, repo string, cacheId int32) ApiActionsDeleteActionsCacheByIdRequest {
	return ApiActionsDeleteActionsCacheByIdRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		cacheId: cacheId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteActionsCacheByIdExecute(r ApiActionsDeleteActionsCacheByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteActionsCacheById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/caches/{cache_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cache_id"+"}", url.PathEscape(parameterToString(r.cacheId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteActionsCacheByKeyRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	key *string
	ref *string
}

// A key for identifying the cache.
func (r ApiActionsDeleteActionsCacheByKeyRequest) Key(key string) ApiActionsDeleteActionsCacheByKeyRequest {
	r.key = &key
	return r
}

// The Git reference for the results you want to list. The &#x60;ref&#x60; for a branch can be formatted either as &#x60;refs/heads/&lt;branch name&gt;&#x60; or simply &#x60;&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;.
func (r ApiActionsDeleteActionsCacheByKeyRequest) Ref(ref string) ApiActionsDeleteActionsCacheByKeyRequest {
	r.ref = &ref
	return r
}

func (r ApiActionsDeleteActionsCacheByKeyRequest) Execute() (*ActionsCacheList, *http.Response, error) {
	return r.ApiService.ActionsDeleteActionsCacheByKeyExecute(r)
}

/*
ActionsDeleteActionsCacheByKey Delete GitHub Actions caches for a repository (using a cache key)

Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to restrict deletions to caches that match both the provided key and the Git ref.

You must authenticate using an access token with the `repo` scope to use this endpoint.

GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsDeleteActionsCacheByKeyRequest
*/
func (a *ActionsApiService) ActionsDeleteActionsCacheByKey(ctx context.Context, owner string, repo string) ApiActionsDeleteActionsCacheByKeyRequest {
	return ApiActionsDeleteActionsCacheByKeyRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsCacheList
func (a *ActionsApiService) ActionsDeleteActionsCacheByKeyExecute(r ApiActionsDeleteActionsCacheByKeyRequest) (*ActionsCacheList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsCacheList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteActionsCacheByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/caches"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}

	localVarQueryParams.Add("key", parameterToString(*r.key, ""))
	if r.ref != nil {
		localVarQueryParams.Add("ref", parameterToString(*r.ref, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsDeleteArtifactRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	artifactId int32
}

func (r ApiActionsDeleteArtifactRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteArtifactExecute(r)
}

/*
ActionsDeleteArtifact Delete an artifact

Deletes an artifact for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param artifactId The unique identifier of the artifact.
 @return ApiActionsDeleteArtifactRequest
*/
func (a *ActionsApiService) ActionsDeleteArtifact(ctx context.Context, owner string, repo string, artifactId int32) ApiActionsDeleteArtifactRequest {
	return ApiActionsDeleteArtifactRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		artifactId: artifactId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteArtifactExecute(r ApiActionsDeleteArtifactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteArtifact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifact_id"+"}", url.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteEnvironmentSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	repositoryId int32
	environmentName string
	secretName string
}

func (r ApiActionsDeleteEnvironmentSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteEnvironmentSecretExecute(r)
}

/*
ActionsDeleteEnvironmentSecret Delete an environment secret

Deletes a secret in an environment using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryId The unique identifier of the repository.
 @param environmentName The name of the environment
 @param secretName The name of the secret.
 @return ApiActionsDeleteEnvironmentSecretRequest
*/
func (a *ActionsApiService) ActionsDeleteEnvironmentSecret(ctx context.Context, repositoryId int32, environmentName string, secretName string) ApiActionsDeleteEnvironmentSecretRequest {
	return ApiActionsDeleteEnvironmentSecretRequest{
		ApiService: a,
		ctx: ctx,
		repositoryId: repositoryId,
		environmentName: environmentName,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteEnvironmentSecretExecute(r ApiActionsDeleteEnvironmentSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteEnvironmentSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_name"+"}", url.PathEscape(parameterToString(r.environmentName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
}

func (r ApiActionsDeleteOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteOrgSecretExecute(r)
}

/*
ActionsDeleteOrgSecret Delete an organization secret

Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsDeleteOrgSecretRequest
*/
func (a *ActionsApiService) ActionsDeleteOrgSecret(ctx context.Context, org string, secretName string) ApiActionsDeleteOrgSecretRequest {
	return ApiActionsDeleteOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteOrgSecretExecute(r ApiActionsDeleteOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteRepoSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	secretName string
}

func (r ApiActionsDeleteRepoSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteRepoSecretExecute(r)
}

/*
ActionsDeleteRepoSecret Delete a repository secret

Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsDeleteRepoSecretRequest
*/
func (a *ActionsApiService) ActionsDeleteRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiActionsDeleteRepoSecretRequest {
	return ApiActionsDeleteRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteRepoSecretExecute(r ApiActionsDeleteRepoSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteRepoSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteSelfHostedRunnerFromOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
}

func (r ApiActionsDeleteSelfHostedRunnerFromOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteSelfHostedRunnerFromOrgExecute(r)
}

/*
ActionsDeleteSelfHostedRunnerFromOrg Delete a self-hosted runner from an organization

Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsDeleteSelfHostedRunnerFromOrgRequest
*/
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, org string, runnerId int32) ApiActionsDeleteSelfHostedRunnerFromOrgRequest {
	return ApiActionsDeleteSelfHostedRunnerFromOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerFromOrgExecute(r ApiActionsDeleteSelfHostedRunnerFromOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteSelfHostedRunnerFromOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteSelfHostedRunnerFromRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
}

func (r ApiActionsDeleteSelfHostedRunnerFromRepoRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteSelfHostedRunnerFromRepoExecute(r)
}

/*
ActionsDeleteSelfHostedRunnerFromRepo Delete a self-hosted runner from a repository

Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.

You must authenticate using an access token with the `repo`
scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsDeleteSelfHostedRunnerFromRepoRequest
*/
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsDeleteSelfHostedRunnerFromRepoRequest {
	return ApiActionsDeleteSelfHostedRunnerFromRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerFromRepoExecute(r ApiActionsDeleteSelfHostedRunnerFromRepoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteSelfHostedRunnerFromRepo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
}

func (r ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteSelfHostedRunnerGroupFromOrgExecute(r)
}

/*
ActionsDeleteSelfHostedRunnerGroupFromOrg Delete a self-hosted runner group from an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Deletes a self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest
*/
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest {
	return ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteSelfHostedRunnerGroupFromOrgExecute(r ApiActionsDeleteSelfHostedRunnerGroupFromOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteSelfHostedRunnerGroupFromOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsDeleteWorkflowRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteWorkflowRunExecute(r)
}

/*
ActionsDeleteWorkflowRun Delete a workflow run

Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsDeleteWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsDeleteWorkflowRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsDeleteWorkflowRunRequest {
	return ApiActionsDeleteWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteWorkflowRunExecute(r ApiActionsDeleteWorkflowRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteWorkflowRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDeleteWorkflowRunLogsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsDeleteWorkflowRunLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDeleteWorkflowRunLogsExecute(r)
}

/*
ActionsDeleteWorkflowRunLogs Delete workflow run logs

Deletes all logs for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsDeleteWorkflowRunLogsRequest
*/
func (a *ActionsApiService) ActionsDeleteWorkflowRunLogs(ctx context.Context, owner string, repo string, runId int32) ApiActionsDeleteWorkflowRunLogsRequest {
	return ApiActionsDeleteWorkflowRunLogsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDeleteWorkflowRunLogsExecute(r ApiActionsDeleteWorkflowRunLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDeleteWorkflowRunLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	repositoryId int32
}

func (r ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDisableSelectedRepositoryGithubActionsOrganizationExecute(r)
}

/*
ActionsDisableSelectedRepositoryGithubActionsOrganization Disable a selected repository for GitHub Actions in an organization

Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param repositoryId The unique identifier of the repository.
 @return ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org string, repositoryId int32) ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest {
	return ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDisableSelectedRepositoryGithubActionsOrganizationExecute(r ApiActionsDisableSelectedRepositoryGithubActionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDisableSelectedRepositoryGithubActionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDisableWorkflowRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
}

func (r ApiActionsDisableWorkflowRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDisableWorkflowExecute(r)
}

/*
ActionsDisableWorkflow Disable a workflow

Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsDisableWorkflowRequest
*/
func (a *ActionsApiService) ActionsDisableWorkflow(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsDisableWorkflowRequest {
	return ApiActionsDisableWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDisableWorkflowExecute(r ApiActionsDisableWorkflowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDisableWorkflow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDownloadArtifactRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	artifactId int32
	archiveFormat string
}

func (r ApiActionsDownloadArtifactRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDownloadArtifactExecute(r)
}

/*
ActionsDownloadArtifact Download an artifact

Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone with read access to
the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param artifactId The unique identifier of the artifact.
 @param archiveFormat
 @return ApiActionsDownloadArtifactRequest
*/
func (a *ActionsApiService) ActionsDownloadArtifact(ctx context.Context, owner string, repo string, artifactId int32, archiveFormat string) ApiActionsDownloadArtifactRequest {
	return ApiActionsDownloadArtifactRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		artifactId: artifactId,
		archiveFormat: archiveFormat,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDownloadArtifactExecute(r ApiActionsDownloadArtifactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDownloadArtifact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifact_id"+"}", url.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"archive_format"+"}", url.PathEscape(parameterToString(r.archiveFormat, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDownloadJobLogsForWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	jobId int32
}

func (r ApiActionsDownloadJobLogsForWorkflowRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDownloadJobLogsForWorkflowRunExecute(r)
}

/*
ActionsDownloadJobLogsForWorkflowRun Download job logs for a workflow run

Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
for `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can
use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must
have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param jobId The unique identifier of the job.
 @return ApiActionsDownloadJobLogsForWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, owner string, repo string, jobId int32) ApiActionsDownloadJobLogsForWorkflowRunRequest {
	return ApiActionsDownloadJobLogsForWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDownloadJobLogsForWorkflowRunExecute(r ApiActionsDownloadJobLogsForWorkflowRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDownloadJobLogsForWorkflowRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDownloadWorkflowRunAttemptLogsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	attemptNumber int32
}

func (r ApiActionsDownloadWorkflowRunAttemptLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDownloadWorkflowRunAttemptLogsExecute(r)
}

/*
ActionsDownloadWorkflowRunAttemptLogs Download workflow run attempt logs

Gets a redirect URL to download an archive of log files for a specific workflow run attempt. This link expires after
1 minute. Look for `Location:` in the response header to find the URL for the download. Anyone with read access to
the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @param attemptNumber The attempt number of the workflow run.
 @return ApiActionsDownloadWorkflowRunAttemptLogsRequest
*/
func (a *ActionsApiService) ActionsDownloadWorkflowRunAttemptLogs(ctx context.Context, owner string, repo string, runId int32, attemptNumber int32) ApiActionsDownloadWorkflowRunAttemptLogsRequest {
	return ApiActionsDownloadWorkflowRunAttemptLogsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
		attemptNumber: attemptNumber,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDownloadWorkflowRunAttemptLogsExecute(r ApiActionsDownloadWorkflowRunAttemptLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDownloadWorkflowRunAttemptLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attempt_number"+"}", url.PathEscape(parameterToString(r.attemptNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsDownloadWorkflowRunLogsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsDownloadWorkflowRunLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsDownloadWorkflowRunLogsExecute(r)
}

/*
ActionsDownloadWorkflowRunLogs Download workflow run logs

Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
`Location:` in the response header to find the URL for the download. Anyone with read access to the repository can use
this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have
the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsDownloadWorkflowRunLogsRequest
*/
func (a *ActionsApiService) ActionsDownloadWorkflowRunLogs(ctx context.Context, owner string, repo string, runId int32) ApiActionsDownloadWorkflowRunLogsRequest {
	return ApiActionsDownloadWorkflowRunLogsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsDownloadWorkflowRunLogsExecute(r ApiActionsDownloadWorkflowRunLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsDownloadWorkflowRunLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	repositoryId int32
}

func (r ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsEnableSelectedRepositoryGithubActionsOrganizationExecute(r)
}

/*
ActionsEnableSelectedRepositoryGithubActionsOrganization Enable a selected repository for GitHub Actions in an organization

Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param repositoryId The unique identifier of the repository.
 @return ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org string, repositoryId int32) ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest {
	return ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsEnableSelectedRepositoryGithubActionsOrganizationExecute(r ApiActionsEnableSelectedRepositoryGithubActionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsEnableSelectedRepositoryGithubActionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsEnableWorkflowRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
}

func (r ApiActionsEnableWorkflowRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsEnableWorkflowExecute(r)
}

/*
ActionsEnableWorkflow Enable a workflow

Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsEnableWorkflowRequest
*/
func (a *ActionsApiService) ActionsEnableWorkflow(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsEnableWorkflowRequest {
	return ApiActionsEnableWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsEnableWorkflowExecute(r ApiActionsEnableWorkflowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsEnableWorkflow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsGetActionsCacheListRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	perPage *int32
	page *int32
	ref *string
	key *string
	sort *string
	direction *string
}

// The number of results per page (max 100).
func (r ApiActionsGetActionsCacheListRequest) PerPage(perPage int32) ApiActionsGetActionsCacheListRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsGetActionsCacheListRequest) Page(page int32) ApiActionsGetActionsCacheListRequest {
	r.page = &page
	return r
}

// The Git reference for the results you want to list. The &#x60;ref&#x60; for a branch can be formatted either as &#x60;refs/heads/&lt;branch name&gt;&#x60; or simply &#x60;&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;.
func (r ApiActionsGetActionsCacheListRequest) Ref(ref string) ApiActionsGetActionsCacheListRequest {
	r.ref = &ref
	return r
}

// An explicit key or prefix for identifying the cache
func (r ApiActionsGetActionsCacheListRequest) Key(key string) ApiActionsGetActionsCacheListRequest {
	r.key = &key
	return r
}

// The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes.
func (r ApiActionsGetActionsCacheListRequest) Sort(sort string) ApiActionsGetActionsCacheListRequest {
	r.sort = &sort
	return r
}

// The direction to sort the results by.
func (r ApiActionsGetActionsCacheListRequest) Direction(direction string) ApiActionsGetActionsCacheListRequest {
	r.direction = &direction
	return r
}

func (r ApiActionsGetActionsCacheListRequest) Execute() (*ActionsCacheList, *http.Response, error) {
	return r.ApiService.ActionsGetActionsCacheListExecute(r)
}

/*
ActionsGetActionsCacheList List GitHub Actions caches for a repository

Lists the GitHub Actions caches for a repository.
You must authenticate using an access token with the `repo` scope to use this endpoint.
GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetActionsCacheListRequest
*/
func (a *ActionsApiService) ActionsGetActionsCacheList(ctx context.Context, owner string, repo string) ApiActionsGetActionsCacheListRequest {
	return ApiActionsGetActionsCacheListRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsCacheList
func (a *ActionsApiService) ActionsGetActionsCacheListExecute(r ApiActionsGetActionsCacheListRequest) (*ActionsCacheList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsCacheList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetActionsCacheList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/caches"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.ref != nil {
		localVarQueryParams.Add("ref", parameterToString(*r.ref, ""))
	}
	if r.key != nil {
		localVarQueryParams.Add("key", parameterToString(*r.key, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.direction != nil {
		localVarQueryParams.Add("direction", parameterToString(*r.direction, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetActionsCacheUsageRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetActionsCacheUsageRequest) Execute() (*ActionsCacheUsageByRepository, *http.Response, error) {
	return r.ApiService.ActionsGetActionsCacheUsageExecute(r)
}

/*
ActionsGetActionsCacheUsage Get GitHub Actions cache usage for a repository

Gets GitHub Actions cache usage for a repository.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetActionsCacheUsageRequest
*/
func (a *ActionsApiService) ActionsGetActionsCacheUsage(ctx context.Context, owner string, repo string) ApiActionsGetActionsCacheUsageRequest {
	return ApiActionsGetActionsCacheUsageRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsCacheUsageByRepository
func (a *ActionsApiService) ActionsGetActionsCacheUsageExecute(r ApiActionsGetActionsCacheUsageRequest) (*ActionsCacheUsageByRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsCacheUsageByRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetActionsCacheUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/cache/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetActionsCacheUsageByRepoForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsGetActionsCacheUsageByRepoForOrgRequest) PerPage(perPage int32) ApiActionsGetActionsCacheUsageByRepoForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsGetActionsCacheUsageByRepoForOrgRequest) Page(page int32) ApiActionsGetActionsCacheUsageByRepoForOrgRequest {
	r.page = &page
	return r
}

func (r ApiActionsGetActionsCacheUsageByRepoForOrgRequest) Execute() (*ActionsGetActionsCacheUsageByRepoForOrg200Response, *http.Response, error) {
	return r.ApiService.ActionsGetActionsCacheUsageByRepoForOrgExecute(r)
}

/*
ActionsGetActionsCacheUsageByRepoForOrg List repositories with GitHub Actions cache usage for an organization

Lists repositories and their GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetActionsCacheUsageByRepoForOrgRequest
*/
func (a *ActionsApiService) ActionsGetActionsCacheUsageByRepoForOrg(ctx context.Context, org string) ApiActionsGetActionsCacheUsageByRepoForOrgRequest {
	return ApiActionsGetActionsCacheUsageByRepoForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsGetActionsCacheUsageByRepoForOrg200Response
func (a *ActionsApiService) ActionsGetActionsCacheUsageByRepoForOrgExecute(r ApiActionsGetActionsCacheUsageByRepoForOrgRequest) (*ActionsGetActionsCacheUsageByRepoForOrg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsGetActionsCacheUsageByRepoForOrg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetActionsCacheUsageByRepoForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/cache/usage-by-repository"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetActionsCacheUsageForEnterpriseRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	enterprise string
}

func (r ApiActionsGetActionsCacheUsageForEnterpriseRequest) Execute() (*ActionsCacheUsageOrgEnterprise, *http.Response, error) {
	return r.ApiService.ActionsGetActionsCacheUsageForEnterpriseExecute(r)
}

/*
ActionsGetActionsCacheUsageForEnterprise Get GitHub Actions cache usage for an enterprise

Gets the total GitHub Actions cache usage for an enterprise.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id.
 @return ApiActionsGetActionsCacheUsageForEnterpriseRequest
*/
func (a *ActionsApiService) ActionsGetActionsCacheUsageForEnterprise(ctx context.Context, enterprise string) ApiActionsGetActionsCacheUsageForEnterpriseRequest {
	return ApiActionsGetActionsCacheUsageForEnterpriseRequest{
		ApiService: a,
		ctx: ctx,
		enterprise: enterprise,
	}
}

// Execute executes the request
//  @return ActionsCacheUsageOrgEnterprise
func (a *ActionsApiService) ActionsGetActionsCacheUsageForEnterpriseExecute(r ApiActionsGetActionsCacheUsageForEnterpriseRequest) (*ActionsCacheUsageOrgEnterprise, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsCacheUsageOrgEnterprise
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetActionsCacheUsageForEnterprise")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/enterprises/{enterprise}/actions/cache/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"enterprise"+"}", url.PathEscape(parameterToString(r.enterprise, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetActionsCacheUsageForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsGetActionsCacheUsageForOrgRequest) Execute() (*ActionsCacheUsageOrgEnterprise, *http.Response, error) {
	return r.ApiService.ActionsGetActionsCacheUsageForOrgExecute(r)
}

/*
ActionsGetActionsCacheUsageForOrg Get GitHub Actions cache usage for an organization

Gets the total GitHub Actions cache usage for an organization.
The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get updated.
You must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `organization_admistration:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetActionsCacheUsageForOrgRequest
*/
func (a *ActionsApiService) ActionsGetActionsCacheUsageForOrg(ctx context.Context, org string) ApiActionsGetActionsCacheUsageForOrgRequest {
	return ApiActionsGetActionsCacheUsageForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsCacheUsageOrgEnterprise
func (a *ActionsApiService) ActionsGetActionsCacheUsageForOrgExecute(r ApiActionsGetActionsCacheUsageForOrgRequest) (*ActionsCacheUsageOrgEnterprise, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsCacheUsageOrgEnterprise
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetActionsCacheUsageForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/cache/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetAllowedActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsGetAllowedActionsOrganizationRequest) Execute() (*SelectedActions, *http.Response, error) {
	return r.ApiService.ActionsGetAllowedActionsOrganizationExecute(r)
}

/*
ActionsGetAllowedActionsOrganization Get allowed actions and reusable workflows for an organization

Gets the selected actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetAllowedActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsGetAllowedActionsOrganization(ctx context.Context, org string) ApiActionsGetAllowedActionsOrganizationRequest {
	return ApiActionsGetAllowedActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return SelectedActions
func (a *ActionsApiService) ActionsGetAllowedActionsOrganizationExecute(r ApiActionsGetAllowedActionsOrganizationRequest) (*SelectedActions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SelectedActions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetAllowedActionsOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/selected-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetAllowedActionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetAllowedActionsRepositoryRequest) Execute() (*SelectedActions, *http.Response, error) {
	return r.ApiService.ActionsGetAllowedActionsRepositoryExecute(r)
}

/*
ActionsGetAllowedActionsRepository Get allowed actions and reusable workflows for a repository

Gets the settings for selected actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetAllowedActionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsGetAllowedActionsRepository(ctx context.Context, owner string, repo string) ApiActionsGetAllowedActionsRepositoryRequest {
	return ApiActionsGetAllowedActionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return SelectedActions
func (a *ActionsApiService) ActionsGetAllowedActionsRepositoryExecute(r ApiActionsGetAllowedActionsRepositoryRequest) (*SelectedActions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SelectedActions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetAllowedActionsRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/selected-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetArtifactRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	artifactId int32
}

func (r ApiActionsGetArtifactRequest) Execute() (*Artifact, *http.Response, error) {
	return r.ApiService.ActionsGetArtifactExecute(r)
}

/*
ActionsGetArtifact Get an artifact

Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param artifactId The unique identifier of the artifact.
 @return ApiActionsGetArtifactRequest
*/
func (a *ActionsApiService) ActionsGetArtifact(ctx context.Context, owner string, repo string, artifactId int32) ApiActionsGetArtifactRequest {
	return ApiActionsGetArtifactRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		artifactId: artifactId,
	}
}

// Execute executes the request
//  @return Artifact
func (a *ActionsApiService) ActionsGetArtifactExecute(r ApiActionsGetArtifactRequest) (*Artifact, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Artifact
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetArtifact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifact_id"+"}", url.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetCustomOidcSubClaimForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetCustomOidcSubClaimForRepoRequest) Execute() (*OptOutOidcCustomSub, *http.Response, error) {
	return r.ApiService.ActionsGetCustomOidcSubClaimForRepoExecute(r)
}

/*
ActionsGetCustomOidcSubClaimForRepo Get the opt-out flag of an OIDC subject claim customization for a repository

Gets the `opt-out` flag of a GitHub Actions OpenID Connect (OIDC) subject claim customization for a repository.
You must authenticate using an access token with the `repo` scope to use this
endpoint. GitHub Apps must have the `organization_administration:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetCustomOidcSubClaimForRepoRequest
*/
func (a *ActionsApiService) ActionsGetCustomOidcSubClaimForRepo(ctx context.Context, owner string, repo string) ApiActionsGetCustomOidcSubClaimForRepoRequest {
	return ApiActionsGetCustomOidcSubClaimForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return OptOutOidcCustomSub
func (a *ActionsApiService) ActionsGetCustomOidcSubClaimForRepoExecute(r ApiActionsGetCustomOidcSubClaimForRepoRequest) (*OptOutOidcCustomSub, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptOutOidcCustomSub
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetCustomOidcSubClaimForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/oidc/customization/sub"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/scim+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetEnvironmentPublicKeyRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	repositoryId int32
	environmentName string
}

func (r ApiActionsGetEnvironmentPublicKeyRequest) Execute() (*ActionsPublicKey, *http.Response, error) {
	return r.ApiService.ActionsGetEnvironmentPublicKeyExecute(r)
}

/*
ActionsGetEnvironmentPublicKey Get an environment public key

Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryId The unique identifier of the repository.
 @param environmentName The name of the environment
 @return ApiActionsGetEnvironmentPublicKeyRequest
*/
func (a *ActionsApiService) ActionsGetEnvironmentPublicKey(ctx context.Context, repositoryId int32, environmentName string) ApiActionsGetEnvironmentPublicKeyRequest {
	return ApiActionsGetEnvironmentPublicKeyRequest{
		ApiService: a,
		ctx: ctx,
		repositoryId: repositoryId,
		environmentName: environmentName,
	}
}

// Execute executes the request
//  @return ActionsPublicKey
func (a *ActionsApiService) ActionsGetEnvironmentPublicKeyExecute(r ApiActionsGetEnvironmentPublicKeyRequest) (*ActionsPublicKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsPublicKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetEnvironmentPublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_name"+"}", url.PathEscape(parameterToString(r.environmentName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetEnvironmentSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	repositoryId int32
	environmentName string
	secretName string
}

func (r ApiActionsGetEnvironmentSecretRequest) Execute() (*ActionsSecret, *http.Response, error) {
	return r.ApiService.ActionsGetEnvironmentSecretExecute(r)
}

/*
ActionsGetEnvironmentSecret Get an environment secret

Gets a single environment secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryId The unique identifier of the repository.
 @param environmentName The name of the environment
 @param secretName The name of the secret.
 @return ApiActionsGetEnvironmentSecretRequest
*/
func (a *ActionsApiService) ActionsGetEnvironmentSecret(ctx context.Context, repositoryId int32, environmentName string, secretName string) ApiActionsGetEnvironmentSecretRequest {
	return ApiActionsGetEnvironmentSecretRequest{
		ApiService: a,
		ctx: ctx,
		repositoryId: repositoryId,
		environmentName: environmentName,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return ActionsSecret
func (a *ActionsApiService) ActionsGetEnvironmentSecretExecute(r ApiActionsGetEnvironmentSecretRequest) (*ActionsSecret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetEnvironmentSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_name"+"}", url.PathEscape(parameterToString(r.environmentName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	enterprise string
}

func (r ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest) Execute() (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	return r.ApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseExecute(r)
}

/*
ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise Get default workflow permissions for an enterprise

Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id.
 @return ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest
*/
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise string) ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest {
	return ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest{
		ApiService: a,
		ctx: ctx,
		enterprise: enterprise,
	}
}

// Execute executes the request
//  @return ActionsGetDefaultWorkflowPermissions
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseExecute(r ApiActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest) (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsGetDefaultWorkflowPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/enterprises/{enterprise}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"enterprise"+"}", url.PathEscape(parameterToString(r.enterprise, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest) Execute() (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	return r.ApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationExecute(r)
}

/*
ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization Get default workflow permissions for an organization

Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,
as well as whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org string) ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest {
	return ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsGetDefaultWorkflowPermissions
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationExecute(r ApiActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest) (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsGetDefaultWorkflowPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest) Execute() (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	return r.ApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryExecute(r)
}

/*
ActionsGetGithubActionsDefaultWorkflowPermissionsRepository Get default workflow permissions for a repository

Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,
as well as if GitHub Actions can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner string, repo string) ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest {
	return ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsGetDefaultWorkflowPermissions
func (a *ActionsApiService) ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryExecute(r ApiActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest) (*ActionsGetDefaultWorkflowPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsGetDefaultWorkflowPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetGithubActionsDefaultWorkflowPermissionsRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetGithubActionsPermissionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsGetGithubActionsPermissionsOrganizationRequest) Execute() (*ActionsOrganizationPermissions, *http.Response, error) {
	return r.ApiService.ActionsGetGithubActionsPermissionsOrganizationExecute(r)
}

/*
ActionsGetGithubActionsPermissionsOrganization Get GitHub Actions permissions for an organization

Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetGithubActionsPermissionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, org string) ApiActionsGetGithubActionsPermissionsOrganizationRequest {
	return ApiActionsGetGithubActionsPermissionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsOrganizationPermissions
func (a *ActionsApiService) ActionsGetGithubActionsPermissionsOrganizationExecute(r ApiActionsGetGithubActionsPermissionsOrganizationRequest) (*ActionsOrganizationPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsOrganizationPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetGithubActionsPermissionsOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetGithubActionsPermissionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetGithubActionsPermissionsRepositoryRequest) Execute() (*ActionsRepositoryPermissions, *http.Response, error) {
	return r.ApiService.ActionsGetGithubActionsPermissionsRepositoryExecute(r)
}

/*
ActionsGetGithubActionsPermissionsRepository Get GitHub Actions permissions for a repository

Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetGithubActionsPermissionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, owner string, repo string) ApiActionsGetGithubActionsPermissionsRepositoryRequest {
	return ApiActionsGetGithubActionsPermissionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsRepositoryPermissions
func (a *ActionsApiService) ActionsGetGithubActionsPermissionsRepositoryExecute(r ApiActionsGetGithubActionsPermissionsRepositoryRequest) (*ActionsRepositoryPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsRepositoryPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetGithubActionsPermissionsRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetJobForWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	jobId int32
}

func (r ApiActionsGetJobForWorkflowRunRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.ActionsGetJobForWorkflowRunExecute(r)
}

/*
ActionsGetJobForWorkflowRun Get a job for a workflow run

Gets a specific job in a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param jobId The unique identifier of the job.
 @return ApiActionsGetJobForWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsGetJobForWorkflowRun(ctx context.Context, owner string, repo string, jobId int32) ApiActionsGetJobForWorkflowRunRequest {
	return ApiActionsGetJobForWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return Job
func (a *ActionsApiService) ActionsGetJobForWorkflowRunExecute(r ApiActionsGetJobForWorkflowRunRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetJobForWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/jobs/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetOrgPublicKeyRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsGetOrgPublicKeyRequest) Execute() (*ActionsPublicKey, *http.Response, error) {
	return r.ApiService.ActionsGetOrgPublicKeyExecute(r)
}

/*
ActionsGetOrgPublicKey Get an organization public key

Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsGetOrgPublicKeyRequest
*/
func (a *ActionsApiService) ActionsGetOrgPublicKey(ctx context.Context, org string) ApiActionsGetOrgPublicKeyRequest {
	return ApiActionsGetOrgPublicKeyRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsPublicKey
func (a *ActionsApiService) ActionsGetOrgPublicKeyExecute(r ApiActionsGetOrgPublicKeyRequest) (*ActionsPublicKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsPublicKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetOrgPublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
}

func (r ApiActionsGetOrgSecretRequest) Execute() (*OrganizationActionsSecret, *http.Response, error) {
	return r.ApiService.ActionsGetOrgSecretExecute(r)
}

/*
ActionsGetOrgSecret Get an organization secret

Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsGetOrgSecretRequest
*/
func (a *ActionsApiService) ActionsGetOrgSecret(ctx context.Context, org string, secretName string) ApiActionsGetOrgSecretRequest {
	return ApiActionsGetOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return OrganizationActionsSecret
func (a *ActionsApiService) ActionsGetOrgSecretExecute(r ApiActionsGetOrgSecretRequest) (*OrganizationActionsSecret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationActionsSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetPendingDeploymentsForRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsGetPendingDeploymentsForRunRequest) Execute() ([]PendingDeployment, *http.Response, error) {
	return r.ApiService.ActionsGetPendingDeploymentsForRunExecute(r)
}

/*
ActionsGetPendingDeploymentsForRun Get pending deployments for a workflow run

Get all deployment environments for a workflow run that are waiting for protection rules to pass.

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsGetPendingDeploymentsForRunRequest
*/
func (a *ActionsApiService) ActionsGetPendingDeploymentsForRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsGetPendingDeploymentsForRunRequest {
	return ApiActionsGetPendingDeploymentsForRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return []PendingDeployment
func (a *ActionsApiService) ActionsGetPendingDeploymentsForRunExecute(r ApiActionsGetPendingDeploymentsForRunRequest) ([]PendingDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PendingDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetPendingDeploymentsForRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetRepoPublicKeyRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetRepoPublicKeyRequest) Execute() (*ActionsPublicKey, *http.Response, error) {
	return r.ApiService.ActionsGetRepoPublicKeyExecute(r)
}

/*
ActionsGetRepoPublicKey Get a repository public key

Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetRepoPublicKeyRequest
*/
func (a *ActionsApiService) ActionsGetRepoPublicKey(ctx context.Context, owner string, repo string) ApiActionsGetRepoPublicKeyRequest {
	return ApiActionsGetRepoPublicKeyRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsPublicKey
func (a *ActionsApiService) ActionsGetRepoPublicKeyExecute(r ApiActionsGetRepoPublicKeyRequest) (*ActionsPublicKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsPublicKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetRepoPublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/secrets/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetRepoSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	secretName string
}

func (r ApiActionsGetRepoSecretRequest) Execute() (*ActionsSecret, *http.Response, error) {
	return r.ApiService.ActionsGetRepoSecretExecute(r)
}

/*
ActionsGetRepoSecret Get a repository secret

Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsGetRepoSecretRequest
*/
func (a *ActionsApiService) ActionsGetRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiActionsGetRepoSecretRequest {
	return ApiActionsGetRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return ActionsSecret
func (a *ActionsApiService) ActionsGetRepoSecretExecute(r ApiActionsGetRepoSecretRequest) (*ActionsSecret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetRepoSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetReviewsForRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsGetReviewsForRunRequest) Execute() ([]EnvironmentApprovals, *http.Response, error) {
	return r.ApiService.ActionsGetReviewsForRunExecute(r)
}

/*
ActionsGetReviewsForRun Get the review history for a workflow run

Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsGetReviewsForRunRequest
*/
func (a *ActionsApiService) ActionsGetReviewsForRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsGetReviewsForRunRequest {
	return ApiActionsGetReviewsForRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return []EnvironmentApprovals
func (a *ActionsApiService) ActionsGetReviewsForRunExecute(r ApiActionsGetReviewsForRunRequest) ([]EnvironmentApprovals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnvironmentApprovals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetReviewsForRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
}

func (r ApiActionsGetSelfHostedRunnerForOrgRequest) Execute() (*Runner, *http.Response, error) {
	return r.ApiService.ActionsGetSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsGetSelfHostedRunnerForOrg Get a self-hosted runner for an organization

Gets a specific self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsGetSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32) ApiActionsGetSelfHostedRunnerForOrgRequest {
	return ApiActionsGetSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return Runner
func (a *ActionsApiService) ActionsGetSelfHostedRunnerForOrgExecute(r ApiActionsGetSelfHostedRunnerForOrgRequest) (*Runner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Runner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
}

func (r ApiActionsGetSelfHostedRunnerForRepoRequest) Execute() (*Runner, *http.Response, error) {
	return r.ApiService.ActionsGetSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsGetSelfHostedRunnerForRepo Get a self-hosted runner for a repository

Gets a specific self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsGetSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsGetSelfHostedRunnerForRepoRequest {
	return ApiActionsGetSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return Runner
func (a *ActionsApiService) ActionsGetSelfHostedRunnerForRepoExecute(r ApiActionsGetSelfHostedRunnerForRepoRequest) (*Runner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Runner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetSelfHostedRunnerGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
}

func (r ApiActionsGetSelfHostedRunnerGroupForOrgRequest) Execute() (*RunnerGroupsOrg, *http.Response, error) {
	return r.ApiService.ActionsGetSelfHostedRunnerGroupForOrgExecute(r)
}

/*
ActionsGetSelfHostedRunnerGroupForOrg Get a self-hosted runner group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Gets a specific self-hosted runner group for an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsGetSelfHostedRunnerGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsGetSelfHostedRunnerGroupForOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsGetSelfHostedRunnerGroupForOrgRequest {
	return ApiActionsGetSelfHostedRunnerGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
//  @return RunnerGroupsOrg
func (a *ActionsApiService) ActionsGetSelfHostedRunnerGroupForOrgExecute(r ApiActionsGetSelfHostedRunnerGroupForOrgRequest) (*RunnerGroupsOrg, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RunnerGroupsOrg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetSelfHostedRunnerGroupForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
}

func (r ApiActionsGetWorkflowRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowExecute(r)
}

/*
ActionsGetWorkflow Get a workflow

Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsGetWorkflowRequest
*/
func (a *ActionsApiService) ActionsGetWorkflow(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsGetWorkflowRequest {
	return ApiActionsGetWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return Workflow
func (a *ActionsApiService) ActionsGetWorkflowExecute(r ApiActionsGetWorkflowRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowAccessToRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsGetWorkflowAccessToRepositoryRequest) Execute() (*ActionsWorkflowAccessToRepository, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowAccessToRepositoryExecute(r)
}

/*
ActionsGetWorkflowAccessToRepository Get the level of access for workflows outside of the repository

Gets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to internal repositories. For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
repository `administration` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsGetWorkflowAccessToRepositoryRequest
*/
func (a *ActionsApiService) ActionsGetWorkflowAccessToRepository(ctx context.Context, owner string, repo string) ApiActionsGetWorkflowAccessToRepositoryRequest {
	return ApiActionsGetWorkflowAccessToRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsWorkflowAccessToRepository
func (a *ActionsApiService) ActionsGetWorkflowAccessToRepositoryExecute(r ApiActionsGetWorkflowAccessToRepositoryRequest) (*ActionsWorkflowAccessToRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsWorkflowAccessToRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflowAccessToRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/access"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	excludePullRequests *bool
}

// If &#x60;true&#x60; pull requests are omitted from the response (empty array).
func (r ApiActionsGetWorkflowRunRequest) ExcludePullRequests(excludePullRequests bool) ApiActionsGetWorkflowRunRequest {
	r.excludePullRequests = &excludePullRequests
	return r
}

func (r ApiActionsGetWorkflowRunRequest) Execute() (*WorkflowRun, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowRunExecute(r)
}

/*
ActionsGetWorkflowRun Get a workflow run

Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsGetWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsGetWorkflowRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsGetWorkflowRunRequest {
	return ApiActionsGetWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return WorkflowRun
func (a *ActionsApiService) ActionsGetWorkflowRunExecute(r ApiActionsGetWorkflowRunRequest) (*WorkflowRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludePullRequests != nil {
		localVarQueryParams.Add("exclude_pull_requests", parameterToString(*r.excludePullRequests, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowRunAttemptRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	attemptNumber int32
	excludePullRequests *bool
}

// If &#x60;true&#x60; pull requests are omitted from the response (empty array).
func (r ApiActionsGetWorkflowRunAttemptRequest) ExcludePullRequests(excludePullRequests bool) ApiActionsGetWorkflowRunAttemptRequest {
	r.excludePullRequests = &excludePullRequests
	return r
}

func (r ApiActionsGetWorkflowRunAttemptRequest) Execute() (*WorkflowRun, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowRunAttemptExecute(r)
}

/*
ActionsGetWorkflowRunAttempt Get a workflow run attempt

Gets a specific workflow run attempt. Anyone with read access to the repository
can use this endpoint. If the repository is private you must use an access token
with the `repo` scope. GitHub Apps must have the `actions:read` permission to
use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @param attemptNumber The attempt number of the workflow run.
 @return ApiActionsGetWorkflowRunAttemptRequest
*/
func (a *ActionsApiService) ActionsGetWorkflowRunAttempt(ctx context.Context, owner string, repo string, runId int32, attemptNumber int32) ApiActionsGetWorkflowRunAttemptRequest {
	return ApiActionsGetWorkflowRunAttemptRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
		attemptNumber: attemptNumber,
	}
}

// Execute executes the request
//  @return WorkflowRun
func (a *ActionsApiService) ActionsGetWorkflowRunAttemptExecute(r ApiActionsGetWorkflowRunAttemptRequest) (*WorkflowRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflowRunAttempt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attempt_number"+"}", url.PathEscape(parameterToString(r.attemptNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludePullRequests != nil {
		localVarQueryParams.Add("exclude_pull_requests", parameterToString(*r.excludePullRequests, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowRunUsageRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
}

func (r ApiActionsGetWorkflowRunUsageRequest) Execute() (*WorkflowRunUsage, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowRunUsageExecute(r)
}

/*
ActionsGetWorkflowRunUsage Get workflow run usage

Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsGetWorkflowRunUsageRequest
*/
func (a *ActionsApiService) ActionsGetWorkflowRunUsage(ctx context.Context, owner string, repo string, runId int32) ApiActionsGetWorkflowRunUsageRequest {
	return ApiActionsGetWorkflowRunUsageRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return WorkflowRunUsage
func (a *ActionsApiService) ActionsGetWorkflowRunUsageExecute(r ApiActionsGetWorkflowRunUsageRequest) (*WorkflowRunUsage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowRunUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflowRunUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/timing"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsGetWorkflowUsageRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
}

func (r ApiActionsGetWorkflowUsageRequest) Execute() (*WorkflowUsage, *http.Response, error) {
	return r.ApiService.ActionsGetWorkflowUsageExecute(r)
}

/*
ActionsGetWorkflowUsage Get workflow usage

Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".

You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsGetWorkflowUsageRequest
*/
func (a *ActionsApiService) ActionsGetWorkflowUsage(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsGetWorkflowUsageRequest {
	return ApiActionsGetWorkflowUsageRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return WorkflowUsage
func (a *ActionsApiService) ActionsGetWorkflowUsageExecute(r ApiActionsGetWorkflowUsageRequest) (*WorkflowUsage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkflowUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsGetWorkflowUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListArtifactsForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListArtifactsForRepoRequest) PerPage(perPage int32) ApiActionsListArtifactsForRepoRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListArtifactsForRepoRequest) Page(page int32) ApiActionsListArtifactsForRepoRequest {
	r.page = &page
	return r
}

func (r ApiActionsListArtifactsForRepoRequest) Execute() (*ActionsListArtifactsForRepo200Response, *http.Response, error) {
	return r.ApiService.ActionsListArtifactsForRepoExecute(r)
}

/*
ActionsListArtifactsForRepo List artifacts for a repository

Lists all artifacts for a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListArtifactsForRepoRequest
*/
func (a *ActionsApiService) ActionsListArtifactsForRepo(ctx context.Context, owner string, repo string) ApiActionsListArtifactsForRepoRequest {
	return ApiActionsListArtifactsForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsListArtifactsForRepo200Response
func (a *ActionsApiService) ActionsListArtifactsForRepoExecute(r ApiActionsListArtifactsForRepoRequest) (*ActionsListArtifactsForRepo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListArtifactsForRepo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListArtifactsForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListEnvironmentSecretsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	repositoryId int32
	environmentName string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListEnvironmentSecretsRequest) PerPage(perPage int32) ApiActionsListEnvironmentSecretsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListEnvironmentSecretsRequest) Page(page int32) ApiActionsListEnvironmentSecretsRequest {
	r.page = &page
	return r
}

func (r ApiActionsListEnvironmentSecretsRequest) Execute() (*ActionsListRepoSecrets200Response, *http.Response, error) {
	return r.ApiService.ActionsListEnvironmentSecretsExecute(r)
}

/*
ActionsListEnvironmentSecrets List environment secrets

Lists all secrets available in an environment without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryId The unique identifier of the repository.
 @param environmentName The name of the environment
 @return ApiActionsListEnvironmentSecretsRequest
*/
func (a *ActionsApiService) ActionsListEnvironmentSecrets(ctx context.Context, repositoryId int32, environmentName string) ApiActionsListEnvironmentSecretsRequest {
	return ApiActionsListEnvironmentSecretsRequest{
		ApiService: a,
		ctx: ctx,
		repositoryId: repositoryId,
		environmentName: environmentName,
	}
}

// Execute executes the request
//  @return ActionsListRepoSecrets200Response
func (a *ActionsApiService) ActionsListEnvironmentSecretsExecute(r ApiActionsListEnvironmentSecretsRequest) (*ActionsListRepoSecrets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListRepoSecrets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListEnvironmentSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{repository_id}/environments/{environment_name}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_name"+"}", url.PathEscape(parameterToString(r.environmentName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListJobsForWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	filter *string
	perPage *int32
	page *int32
}

// Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run.
func (r ApiActionsListJobsForWorkflowRunRequest) Filter(filter string) ApiActionsListJobsForWorkflowRunRequest {
	r.filter = &filter
	return r
}

// The number of results per page (max 100).
func (r ApiActionsListJobsForWorkflowRunRequest) PerPage(perPage int32) ApiActionsListJobsForWorkflowRunRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListJobsForWorkflowRunRequest) Page(page int32) ApiActionsListJobsForWorkflowRunRequest {
	r.page = &page
	return r
}

func (r ApiActionsListJobsForWorkflowRunRequest) Execute() (*ActionsListJobsForWorkflowRunAttempt200Response, *http.Response, error) {
	return r.ApiService.ActionsListJobsForWorkflowRunExecute(r)
}

/*
ActionsListJobsForWorkflowRun List jobs for a workflow run

Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsListJobsForWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsListJobsForWorkflowRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsListJobsForWorkflowRunRequest {
	return ApiActionsListJobsForWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return ActionsListJobsForWorkflowRunAttempt200Response
func (a *ActionsApiService) ActionsListJobsForWorkflowRunExecute(r ApiActionsListJobsForWorkflowRunRequest) (*ActionsListJobsForWorkflowRunAttempt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListJobsForWorkflowRunAttempt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListJobsForWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListJobsForWorkflowRunAttemptRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	attemptNumber int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListJobsForWorkflowRunAttemptRequest) PerPage(perPage int32) ApiActionsListJobsForWorkflowRunAttemptRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListJobsForWorkflowRunAttemptRequest) Page(page int32) ApiActionsListJobsForWorkflowRunAttemptRequest {
	r.page = &page
	return r
}

func (r ApiActionsListJobsForWorkflowRunAttemptRequest) Execute() (*ActionsListJobsForWorkflowRunAttempt200Response, *http.Response, error) {
	return r.ApiService.ActionsListJobsForWorkflowRunAttemptExecute(r)
}

/*
ActionsListJobsForWorkflowRunAttempt List jobs for a workflow run attempt

Lists jobs for a specific workflow run attempt. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @param attemptNumber The attempt number of the workflow run.
 @return ApiActionsListJobsForWorkflowRunAttemptRequest
*/
func (a *ActionsApiService) ActionsListJobsForWorkflowRunAttempt(ctx context.Context, owner string, repo string, runId int32, attemptNumber int32) ApiActionsListJobsForWorkflowRunAttemptRequest {
	return ApiActionsListJobsForWorkflowRunAttemptRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
		attemptNumber: attemptNumber,
	}
}

// Execute executes the request
//  @return ActionsListJobsForWorkflowRunAttempt200Response
func (a *ActionsApiService) ActionsListJobsForWorkflowRunAttemptExecute(r ApiActionsListJobsForWorkflowRunAttemptRequest) (*ActionsListJobsForWorkflowRunAttempt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListJobsForWorkflowRunAttempt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListJobsForWorkflowRunAttempt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attempt_number"+"}", url.PathEscape(parameterToString(r.attemptNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListLabelsForSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
}

func (r ApiActionsListLabelsForSelfHostedRunnerForOrgRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsListLabelsForSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsListLabelsForSelfHostedRunnerForOrg List labels for a self-hosted runner for an organization

Lists all labels for a self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsListLabelsForSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsListLabelsForSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32) ApiActionsListLabelsForSelfHostedRunnerForOrgRequest {
	return ApiActionsListLabelsForSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsListLabelsForSelfHostedRunnerForOrgExecute(r ApiActionsListLabelsForSelfHostedRunnerForOrgRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListLabelsForSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListLabelsForSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
}

func (r ApiActionsListLabelsForSelfHostedRunnerForRepoRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsListLabelsForSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsListLabelsForSelfHostedRunnerForRepo List labels for a self-hosted runner for a repository

Lists all labels for a self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsListLabelsForSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsListLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsListLabelsForSelfHostedRunnerForRepoRequest {
	return ApiActionsListLabelsForSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsListLabelsForSelfHostedRunnerForRepoExecute(r ApiActionsListLabelsForSelfHostedRunnerForRepoRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListLabelsForSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListOrgSecretsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListOrgSecretsRequest) PerPage(perPage int32) ApiActionsListOrgSecretsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListOrgSecretsRequest) Page(page int32) ApiActionsListOrgSecretsRequest {
	r.page = &page
	return r
}

func (r ApiActionsListOrgSecretsRequest) Execute() (*ActionsListOrgSecrets200Response, *http.Response, error) {
	return r.ApiService.ActionsListOrgSecretsExecute(r)
}

/*
ActionsListOrgSecrets List organization secrets

Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsListOrgSecretsRequest
*/
func (a *ActionsApiService) ActionsListOrgSecrets(ctx context.Context, org string) ApiActionsListOrgSecretsRequest {
	return ApiActionsListOrgSecretsRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsListOrgSecrets200Response
func (a *ActionsApiService) ActionsListOrgSecretsExecute(r ApiActionsListOrgSecretsRequest) (*ActionsListOrgSecrets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListOrgSecrets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListOrgSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	page *int32
	perPage *int32
}

// Page number of the results to fetch.
func (r ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest) Page(page int32) ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	r.page = &page
	return r
}

// The number of results per page (max 100).
func (r ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest) PerPage(perPage int32) ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	r.perPage = &perPage
	return r
}

func (r ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest) Execute() (*ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response, *http.Response, error) {
	return r.ApiService.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgExecute(r)
}

/*
ActionsListRepoAccessToSelfHostedRunnerGroupInOrg List repository access to a self-hosted runner group in an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists the repositories with access to a self-hosted runner group configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest
*/
func (a *ActionsApiService) ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	return ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
//  @return ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response
func (a *ActionsApiService) ActionsListRepoAccessToSelfHostedRunnerGroupInOrgExecute(r ApiActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest) (*ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListRepoSecretsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListRepoSecretsRequest) PerPage(perPage int32) ApiActionsListRepoSecretsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListRepoSecretsRequest) Page(page int32) ApiActionsListRepoSecretsRequest {
	r.page = &page
	return r
}

func (r ApiActionsListRepoSecretsRequest) Execute() (*ActionsListRepoSecrets200Response, *http.Response, error) {
	return r.ApiService.ActionsListRepoSecretsExecute(r)
}

/*
ActionsListRepoSecrets List repository secrets

Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListRepoSecretsRequest
*/
func (a *ActionsApiService) ActionsListRepoSecrets(ctx context.Context, owner string, repo string) ApiActionsListRepoSecretsRequest {
	return ApiActionsListRepoSecretsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsListRepoSecrets200Response
func (a *ActionsApiService) ActionsListRepoSecretsExecute(r ApiActionsListRepoSecretsRequest) (*ActionsListRepoSecrets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListRepoSecrets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListRepoSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListRepoWorkflowsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListRepoWorkflowsRequest) PerPage(perPage int32) ApiActionsListRepoWorkflowsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListRepoWorkflowsRequest) Page(page int32) ApiActionsListRepoWorkflowsRequest {
	r.page = &page
	return r
}

func (r ApiActionsListRepoWorkflowsRequest) Execute() (*ActionsListRepoWorkflows200Response, *http.Response, error) {
	return r.ApiService.ActionsListRepoWorkflowsExecute(r)
}

/*
ActionsListRepoWorkflows List repository workflows

Lists the workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListRepoWorkflowsRequest
*/
func (a *ActionsApiService) ActionsListRepoWorkflows(ctx context.Context, owner string, repo string) ApiActionsListRepoWorkflowsRequest {
	return ApiActionsListRepoWorkflowsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsListRepoWorkflows200Response
func (a *ActionsApiService) ActionsListRepoWorkflowsExecute(r ApiActionsListRepoWorkflowsRequest) (*ActionsListRepoWorkflows200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListRepoWorkflows200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListRepoWorkflows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListRunnerApplicationsForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
}

func (r ApiActionsListRunnerApplicationsForOrgRequest) Execute() ([]RunnerApplication, *http.Response, error) {
	return r.ApiService.ActionsListRunnerApplicationsForOrgExecute(r)
}

/*
ActionsListRunnerApplicationsForOrg List runner applications for an organization

Lists binaries for the runner application that you can download and run.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsListRunnerApplicationsForOrgRequest
*/
func (a *ActionsApiService) ActionsListRunnerApplicationsForOrg(ctx context.Context, org string) ApiActionsListRunnerApplicationsForOrgRequest {
	return ApiActionsListRunnerApplicationsForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []RunnerApplication
func (a *ActionsApiService) ActionsListRunnerApplicationsForOrgExecute(r ApiActionsListRunnerApplicationsForOrgRequest) ([]RunnerApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RunnerApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListRunnerApplicationsForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/downloads"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListRunnerApplicationsForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
}

func (r ApiActionsListRunnerApplicationsForRepoRequest) Execute() ([]RunnerApplication, *http.Response, error) {
	return r.ApiService.ActionsListRunnerApplicationsForRepoExecute(r)
}

/*
ActionsListRunnerApplicationsForRepo List runner applications for a repository

Lists binaries for the runner application that you can download and run.

You must authenticate using an access token with the `repo` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListRunnerApplicationsForRepoRequest
*/
func (a *ActionsApiService) ActionsListRunnerApplicationsForRepo(ctx context.Context, owner string, repo string) ApiActionsListRunnerApplicationsForRepoRequest {
	return ApiActionsListRunnerApplicationsForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return []RunnerApplication
func (a *ActionsApiService) ActionsListRunnerApplicationsForRepoExecute(r ApiActionsListRunnerApplicationsForRepoRequest) ([]RunnerApplication, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RunnerApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListRunnerApplicationsForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/downloads"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelectedReposForOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
	page *int32
	perPage *int32
}

// Page number of the results to fetch.
func (r ApiActionsListSelectedReposForOrgSecretRequest) Page(page int32) ApiActionsListSelectedReposForOrgSecretRequest {
	r.page = &page
	return r
}

// The number of results per page (max 100).
func (r ApiActionsListSelectedReposForOrgSecretRequest) PerPage(perPage int32) ApiActionsListSelectedReposForOrgSecretRequest {
	r.perPage = &perPage
	return r
}

func (r ApiActionsListSelectedReposForOrgSecretRequest) Execute() (*ActionsListSelectedReposForOrgSecret200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelectedReposForOrgSecretExecute(r)
}

/*
ActionsListSelectedReposForOrgSecret List selected repositories for an organization secret

Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsListSelectedReposForOrgSecretRequest
*/
func (a *ActionsApiService) ActionsListSelectedReposForOrgSecret(ctx context.Context, org string, secretName string) ApiActionsListSelectedReposForOrgSecretRequest {
	return ApiActionsListSelectedReposForOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return ActionsListSelectedReposForOrgSecret200Response
func (a *ActionsApiService) ActionsListSelectedReposForOrgSecretExecute(r ApiActionsListSelectedReposForOrgSecretRequest) (*ActionsListSelectedReposForOrgSecret200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelectedReposForOrgSecret200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelectedReposForOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest) PerPage(perPage int32) ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest) Page(page int32) ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
	r.page = &page
	return r
}

func (r ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest) Execute() (*ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationExecute(r)
}

/*
ActionsListSelectedRepositoriesEnabledGithubActionsOrganization List selected repositories enabled for GitHub Actions in an organization

Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org string) ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
	return ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response
func (a *ActionsApiService) ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationExecute(r ApiActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest) (*ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelfHostedRunnerGroupsForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	perPage *int32
	page *int32
	visibleToRepository *string
}

// The number of results per page (max 100).
func (r ApiActionsListSelfHostedRunnerGroupsForOrgRequest) PerPage(perPage int32) ApiActionsListSelfHostedRunnerGroupsForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListSelfHostedRunnerGroupsForOrgRequest) Page(page int32) ApiActionsListSelfHostedRunnerGroupsForOrgRequest {
	r.page = &page
	return r
}

// Only return runner groups that are allowed to be used by this repository.
func (r ApiActionsListSelfHostedRunnerGroupsForOrgRequest) VisibleToRepository(visibleToRepository string) ApiActionsListSelfHostedRunnerGroupsForOrgRequest {
	r.visibleToRepository = &visibleToRepository
	return r
}

func (r ApiActionsListSelfHostedRunnerGroupsForOrgRequest) Execute() (*ActionsListSelfHostedRunnerGroupsForOrg200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelfHostedRunnerGroupsForOrgExecute(r)
}

/*
ActionsListSelfHostedRunnerGroupsForOrg List self-hosted runner groups for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsListSelfHostedRunnerGroupsForOrgRequest
*/
func (a *ActionsApiService) ActionsListSelfHostedRunnerGroupsForOrg(ctx context.Context, org string) ApiActionsListSelfHostedRunnerGroupsForOrgRequest {
	return ApiActionsListSelfHostedRunnerGroupsForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsListSelfHostedRunnerGroupsForOrg200Response
func (a *ActionsApiService) ActionsListSelfHostedRunnerGroupsForOrgExecute(r ApiActionsListSelfHostedRunnerGroupsForOrgRequest) (*ActionsListSelfHostedRunnerGroupsForOrg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelfHostedRunnerGroupsForOrg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelfHostedRunnerGroupsForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.visibleToRepository != nil {
		localVarQueryParams.Add("visible_to_repository", parameterToString(*r.visibleToRepository, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelfHostedRunnersForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListSelfHostedRunnersForOrgRequest) PerPage(perPage int32) ApiActionsListSelfHostedRunnersForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListSelfHostedRunnersForOrgRequest) Page(page int32) ApiActionsListSelfHostedRunnersForOrgRequest {
	r.page = &page
	return r
}

func (r ApiActionsListSelfHostedRunnersForOrgRequest) Execute() (*ActionsListSelfHostedRunnersForOrg200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelfHostedRunnersForOrgExecute(r)
}

/*
ActionsListSelfHostedRunnersForOrg List self-hosted runners for an organization

Lists all self-hosted runners configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsListSelfHostedRunnersForOrgRequest
*/
func (a *ActionsApiService) ActionsListSelfHostedRunnersForOrg(ctx context.Context, org string) ApiActionsListSelfHostedRunnersForOrgRequest {
	return ApiActionsListSelfHostedRunnersForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ActionsListSelfHostedRunnersForOrg200Response
func (a *ActionsApiService) ActionsListSelfHostedRunnersForOrgExecute(r ApiActionsListSelfHostedRunnersForOrgRequest) (*ActionsListSelfHostedRunnersForOrg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelfHostedRunnersForOrg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelfHostedRunnersForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelfHostedRunnersForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListSelfHostedRunnersForRepoRequest) PerPage(perPage int32) ApiActionsListSelfHostedRunnersForRepoRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListSelfHostedRunnersForRepoRequest) Page(page int32) ApiActionsListSelfHostedRunnersForRepoRequest {
	r.page = &page
	return r
}

func (r ApiActionsListSelfHostedRunnersForRepoRequest) Execute() (*ActionsListSelfHostedRunnersForOrg200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelfHostedRunnersForRepoExecute(r)
}

/*
ActionsListSelfHostedRunnersForRepo List self-hosted runners for a repository

Lists all self-hosted runners configured in a repository. You must authenticate using an access token with the `repo` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListSelfHostedRunnersForRepoRequest
*/
func (a *ActionsApiService) ActionsListSelfHostedRunnersForRepo(ctx context.Context, owner string, repo string) ApiActionsListSelfHostedRunnersForRepoRequest {
	return ApiActionsListSelfHostedRunnersForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsListSelfHostedRunnersForOrg200Response
func (a *ActionsApiService) ActionsListSelfHostedRunnersForRepoExecute(r ApiActionsListSelfHostedRunnersForRepoRequest) (*ActionsListSelfHostedRunnersForOrg200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelfHostedRunnersForOrg200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelfHostedRunnersForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListSelfHostedRunnersInGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListSelfHostedRunnersInGroupForOrgRequest) PerPage(perPage int32) ApiActionsListSelfHostedRunnersInGroupForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListSelfHostedRunnersInGroupForOrgRequest) Page(page int32) ApiActionsListSelfHostedRunnersInGroupForOrgRequest {
	r.page = &page
	return r
}

func (r ApiActionsListSelfHostedRunnersInGroupForOrgRequest) Execute() (*EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsListSelfHostedRunnersInGroupForOrgExecute(r)
}

/*
ActionsListSelfHostedRunnersInGroupForOrg List self-hosted runners in a group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Lists self-hosted runners that are in a specific organization group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsListSelfHostedRunnersInGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsListSelfHostedRunnersInGroupForOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsListSelfHostedRunnersInGroupForOrgRequest {
	return ApiActionsListSelfHostedRunnersInGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response
func (a *ActionsApiService) ActionsListSelfHostedRunnersInGroupForOrgExecute(r ApiActionsListSelfHostedRunnersInGroupForOrgRequest) (*EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListSelfHostedRunnersInGroupForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListWorkflowRunArtifactsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiActionsListWorkflowRunArtifactsRequest) PerPage(perPage int32) ApiActionsListWorkflowRunArtifactsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListWorkflowRunArtifactsRequest) Page(page int32) ApiActionsListWorkflowRunArtifactsRequest {
	r.page = &page
	return r
}

func (r ApiActionsListWorkflowRunArtifactsRequest) Execute() (*ActionsListArtifactsForRepo200Response, *http.Response, error) {
	return r.ApiService.ActionsListWorkflowRunArtifactsExecute(r)
}

/*
ActionsListWorkflowRunArtifacts List workflow run artifacts

Lists artifacts for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsListWorkflowRunArtifactsRequest
*/
func (a *ActionsApiService) ActionsListWorkflowRunArtifacts(ctx context.Context, owner string, repo string, runId int32) ApiActionsListWorkflowRunArtifactsRequest {
	return ApiActionsListWorkflowRunArtifactsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return ActionsListArtifactsForRepo200Response
func (a *ActionsApiService) ActionsListWorkflowRunArtifactsExecute(r ApiActionsListWorkflowRunArtifactsRequest) (*ActionsListArtifactsForRepo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListArtifactsForRepo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListWorkflowRunArtifacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListWorkflowRunsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	workflowId ActionsGetWorkflowWorkflowIdParameter
	actor *string
	branch *string
	event *string
	status *string
	perPage *int32
	page *int32
	created *time.Time
	excludePullRequests *bool
	checkSuiteId *int32
}

// Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run.
func (r ApiActionsListWorkflowRunsRequest) Actor(actor string) ApiActionsListWorkflowRunsRequest {
	r.actor = &actor
	return r
}

// Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;.
func (r ApiActionsListWorkflowRunsRequest) Branch(branch string) ApiActionsListWorkflowRunsRequest {
	r.branch = &branch
	return r
}

// Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot;
func (r ApiActionsListWorkflowRunsRequest) Event(event string) ApiActionsListWorkflowRunsRequest {
	r.event = &event
	return r
}

// Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub can set a status of &#x60;waiting&#x60; or &#x60;requested&#x60;. For a list of the possible &#x60;status&#x60; and &#x60;conclusion&#x60; options, see \&quot;[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run).\&quot;
func (r ApiActionsListWorkflowRunsRequest) Status(status string) ApiActionsListWorkflowRunsRequest {
	r.status = &status
	return r
}

// The number of results per page (max 100).
func (r ApiActionsListWorkflowRunsRequest) PerPage(perPage int32) ApiActionsListWorkflowRunsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListWorkflowRunsRequest) Page(page int32) ApiActionsListWorkflowRunsRequest {
	r.page = &page
	return r
}

// Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot;
func (r ApiActionsListWorkflowRunsRequest) Created(created time.Time) ApiActionsListWorkflowRunsRequest {
	r.created = &created
	return r
}

// If &#x60;true&#x60; pull requests are omitted from the response (empty array).
func (r ApiActionsListWorkflowRunsRequest) ExcludePullRequests(excludePullRequests bool) ApiActionsListWorkflowRunsRequest {
	r.excludePullRequests = &excludePullRequests
	return r
}

// Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify.
func (r ApiActionsListWorkflowRunsRequest) CheckSuiteId(checkSuiteId int32) ApiActionsListWorkflowRunsRequest {
	r.checkSuiteId = &checkSuiteId
	return r
}

func (r ApiActionsListWorkflowRunsRequest) Execute() (*ActionsListWorkflowRunsForRepo200Response, *http.Response, error) {
	return r.ApiService.ActionsListWorkflowRunsExecute(r)
}

/*
ActionsListWorkflowRuns List workflow runs

List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param workflowId The ID of the workflow. You can also pass the workflow file name as a string.
 @return ApiActionsListWorkflowRunsRequest
*/
func (a *ActionsApiService) ActionsListWorkflowRuns(ctx context.Context, owner string, repo string, workflowId ActionsGetWorkflowWorkflowIdParameter) ApiActionsListWorkflowRunsRequest {
	return ApiActionsListWorkflowRunsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return ActionsListWorkflowRunsForRepo200Response
func (a *ActionsApiService) ActionsListWorkflowRunsExecute(r ApiActionsListWorkflowRunsRequest) (*ActionsListWorkflowRunsForRepo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListWorkflowRunsForRepo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListWorkflowRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterToString(r.workflowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.actor != nil {
		localVarQueryParams.Add("actor", parameterToString(*r.actor, ""))
	}
	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.event != nil {
		localVarQueryParams.Add("event", parameterToString(*r.event, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.excludePullRequests != nil {
		localVarQueryParams.Add("exclude_pull_requests", parameterToString(*r.excludePullRequests, ""))
	}
	if r.checkSuiteId != nil {
		localVarQueryParams.Add("check_suite_id", parameterToString(*r.checkSuiteId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsListWorkflowRunsForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	actor *string
	branch *string
	event *string
	status *string
	perPage *int32
	page *int32
	created *time.Time
	excludePullRequests *bool
	checkSuiteId *int32
}

// Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run.
func (r ApiActionsListWorkflowRunsForRepoRequest) Actor(actor string) ApiActionsListWorkflowRunsForRepoRequest {
	r.actor = &actor
	return r
}

// Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;.
func (r ApiActionsListWorkflowRunsForRepoRequest) Branch(branch string) ApiActionsListWorkflowRunsForRepoRequest {
	r.branch = &branch
	return r
}

// Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot;
func (r ApiActionsListWorkflowRunsForRepoRequest) Event(event string) ApiActionsListWorkflowRunsForRepoRequest {
	r.event = &event
	return r
}

// Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub can set a status of &#x60;waiting&#x60; or &#x60;requested&#x60;. For a list of the possible &#x60;status&#x60; and &#x60;conclusion&#x60; options, see \&quot;[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run).\&quot;
func (r ApiActionsListWorkflowRunsForRepoRequest) Status(status string) ApiActionsListWorkflowRunsForRepoRequest {
	r.status = &status
	return r
}

// The number of results per page (max 100).
func (r ApiActionsListWorkflowRunsForRepoRequest) PerPage(perPage int32) ApiActionsListWorkflowRunsForRepoRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiActionsListWorkflowRunsForRepoRequest) Page(page int32) ApiActionsListWorkflowRunsForRepoRequest {
	r.page = &page
	return r
}

// Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot;
func (r ApiActionsListWorkflowRunsForRepoRequest) Created(created time.Time) ApiActionsListWorkflowRunsForRepoRequest {
	r.created = &created
	return r
}

// If &#x60;true&#x60; pull requests are omitted from the response (empty array).
func (r ApiActionsListWorkflowRunsForRepoRequest) ExcludePullRequests(excludePullRequests bool) ApiActionsListWorkflowRunsForRepoRequest {
	r.excludePullRequests = &excludePullRequests
	return r
}

// Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify.
func (r ApiActionsListWorkflowRunsForRepoRequest) CheckSuiteId(checkSuiteId int32) ApiActionsListWorkflowRunsForRepoRequest {
	r.checkSuiteId = &checkSuiteId
	return r
}

func (r ApiActionsListWorkflowRunsForRepoRequest) Execute() (*ActionsListWorkflowRunsForRepo200Response, *http.Response, error) {
	return r.ApiService.ActionsListWorkflowRunsForRepoExecute(r)
}

/*
ActionsListWorkflowRunsForRepo List workflow runs for a repository

Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).

Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsListWorkflowRunsForRepoRequest
*/
func (a *ActionsApiService) ActionsListWorkflowRunsForRepo(ctx context.Context, owner string, repo string) ApiActionsListWorkflowRunsForRepoRequest {
	return ApiActionsListWorkflowRunsForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return ActionsListWorkflowRunsForRepo200Response
func (a *ActionsApiService) ActionsListWorkflowRunsForRepoExecute(r ApiActionsListWorkflowRunsForRepoRequest) (*ActionsListWorkflowRunsForRepo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListWorkflowRunsForRepo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsListWorkflowRunsForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.actor != nil {
		localVarQueryParams.Add("actor", parameterToString(*r.actor, ""))
	}
	if r.branch != nil {
		localVarQueryParams.Add("branch", parameterToString(*r.branch, ""))
	}
	if r.event != nil {
		localVarQueryParams.Add("event", parameterToString(*r.event, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.excludePullRequests != nil {
		localVarQueryParams.Add("exclude_pull_requests", parameterToString(*r.excludePullRequests, ""))
	}
	if r.checkSuiteId != nil {
		localVarQueryParams.Add("check_suite_id", parameterToString(*r.checkSuiteId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsReRunJobForWorkflowRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	jobId int32
	actionsReRunJobForWorkflowRunRequest *ActionsReRunJobForWorkflowRunRequest
}

func (r ApiActionsReRunJobForWorkflowRunRequest) ActionsReRunJobForWorkflowRunRequest(actionsReRunJobForWorkflowRunRequest ActionsReRunJobForWorkflowRunRequest) ApiActionsReRunJobForWorkflowRunRequest {
	r.actionsReRunJobForWorkflowRunRequest = &actionsReRunJobForWorkflowRunRequest
	return r
}

func (r ApiActionsReRunJobForWorkflowRunRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsReRunJobForWorkflowRunExecute(r)
}

/*
ActionsReRunJobForWorkflowRun Re-run a job from a workflow run

Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param jobId The unique identifier of the job.
 @return ApiActionsReRunJobForWorkflowRunRequest
*/
func (a *ActionsApiService) ActionsReRunJobForWorkflowRun(ctx context.Context, owner string, repo string, jobId int32) ApiActionsReRunJobForWorkflowRunRequest {
	return ApiActionsReRunJobForWorkflowRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsReRunJobForWorkflowRunExecute(r ApiActionsReRunJobForWorkflowRunRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsReRunJobForWorkflowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsReRunJobForWorkflowRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsReRunWorkflowRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	actionsReRunJobForWorkflowRunRequest *ActionsReRunJobForWorkflowRunRequest
}

func (r ApiActionsReRunWorkflowRequest) ActionsReRunJobForWorkflowRunRequest(actionsReRunJobForWorkflowRunRequest ActionsReRunJobForWorkflowRunRequest) ApiActionsReRunWorkflowRequest {
	r.actionsReRunJobForWorkflowRunRequest = &actionsReRunJobForWorkflowRunRequest
	return r
}

func (r ApiActionsReRunWorkflowRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsReRunWorkflowExecute(r)
}

/*
ActionsReRunWorkflow Re-run a workflow

Re-runs your workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsReRunWorkflowRequest
*/
func (a *ActionsApiService) ActionsReRunWorkflow(ctx context.Context, owner string, repo string, runId int32) ApiActionsReRunWorkflowRequest {
	return ApiActionsReRunWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsReRunWorkflowExecute(r ApiActionsReRunWorkflowRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsReRunWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsReRunJobForWorkflowRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsReRunWorkflowFailedJobsRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	actionsReRunJobForWorkflowRunRequest *ActionsReRunJobForWorkflowRunRequest
}

func (r ApiActionsReRunWorkflowFailedJobsRequest) ActionsReRunJobForWorkflowRunRequest(actionsReRunJobForWorkflowRunRequest ActionsReRunJobForWorkflowRunRequest) ApiActionsReRunWorkflowFailedJobsRequest {
	r.actionsReRunJobForWorkflowRunRequest = &actionsReRunJobForWorkflowRunRequest
	return r
}

func (r ApiActionsReRunWorkflowFailedJobsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsReRunWorkflowFailedJobsExecute(r)
}

/*
ActionsReRunWorkflowFailedJobs Re-run failed jobs from a workflow run

Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of the workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsReRunWorkflowFailedJobsRequest
*/
func (a *ActionsApiService) ActionsReRunWorkflowFailedJobs(ctx context.Context, owner string, repo string, runId int32) ApiActionsReRunWorkflowFailedJobsRequest {
	return ApiActionsReRunWorkflowFailedJobsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsReRunWorkflowFailedJobsExecute(r ApiActionsReRunWorkflowFailedJobsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsReRunWorkflowFailedJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsReRunJobForWorkflowRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
}

func (r ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg Remove all custom labels from a self-hosted runner for an organization

Remove all custom labels from a self-hosted runner configured in an
organization. Returns the remaining read-only labels from the runner.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32) ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest {
	return ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgExecute(r ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
}

func (r ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo Remove all custom labels from a self-hosted runner for a repository

Remove all custom labels from a self-hosted runner configured in a
repository. Returns the remaining read-only labels from the runner.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest {
	return ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoExecute(r ApiActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
	name string
}

func (r ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg Remove a custom label from a self-hosted runner for an organization

Remove a custom label from a self-hosted runner configured
in an organization. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @param name The name of a self-hosted runner's custom label.
 @return ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32, name string) ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest {
	return ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
		name: name,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgExecute(r ApiActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}/labels/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
	name string
}

func (r ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo Remove a custom label from a self-hosted runner for a repository

Remove a custom label from a self-hosted runner configured
in a repository. Returns the remaining labels from the runner.

This endpoint returns a `404 Not Found` status if the custom label is not
present on the runner.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @param name The name of a self-hosted runner's custom label.
 @return ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32, name string) ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest {
	return ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
		name: name,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoExecute(r ApiActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	repositoryId int32
}

func (r ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgExecute(r)
}

/*
ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg Remove repository access to a self-hosted runner group in an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @param repositoryId The unique identifier of the repository.
 @return ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest
*/
func (a *ActionsApiService) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org string, runnerGroupId int32, repositoryId int32) ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	return ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgExecute(r ApiActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsRemoveSelectedRepoFromOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
	repositoryId int32
}

func (r ApiActionsRemoveSelectedRepoFromOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsRemoveSelectedRepoFromOrgSecretExecute(r)
}

/*
ActionsRemoveSelectedRepoFromOrgSecret Remove selected repository from an organization secret

Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @param repositoryId
 @return ApiActionsRemoveSelectedRepoFromOrgSecretRequest
*/
func (a *ActionsApiService) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, org string, secretName string, repositoryId int32) ApiActionsRemoveSelectedRepoFromOrgSecretRequest {
	return ApiActionsRemoveSelectedRepoFromOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsRemoveSelectedRepoFromOrgSecretExecute(r ApiActionsRemoveSelectedRepoFromOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveSelectedRepoFromOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	runnerId int32
}

func (r ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsRemoveSelfHostedRunnerFromGroupForOrgExecute(r)
}

/*
ActionsRemoveSelfHostedRunnerFromGroupForOrg Remove a self-hosted runner from a group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."


Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, org string, runnerGroupId int32, runnerId int32) ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest {
	return ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
		runnerId: runnerId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsRemoveSelfHostedRunnerFromGroupForOrgExecute(r ApiActionsRemoveSelfHostedRunnerFromGroupForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsRemoveSelfHostedRunnerFromGroupForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsReviewPendingDeploymentsForRunRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runId int32
	actionsReviewPendingDeploymentsForRunRequest *ActionsReviewPendingDeploymentsForRunRequest
}

func (r ApiActionsReviewPendingDeploymentsForRunRequest) ActionsReviewPendingDeploymentsForRunRequest(actionsReviewPendingDeploymentsForRunRequest ActionsReviewPendingDeploymentsForRunRequest) ApiActionsReviewPendingDeploymentsForRunRequest {
	r.actionsReviewPendingDeploymentsForRunRequest = &actionsReviewPendingDeploymentsForRunRequest
	return r
}

func (r ApiActionsReviewPendingDeploymentsForRunRequest) Execute() ([]Deployment, *http.Response, error) {
	return r.ApiService.ActionsReviewPendingDeploymentsForRunExecute(r)
}

/*
ActionsReviewPendingDeploymentsForRun Review pending deployments for a workflow run

Approve or reject pending deployments that are waiting on approval by a required reviewer.

Required reviewers with read access to the repository contents and deployments can use this endpoint. Required reviewers must authenticate using an access token with the `repo` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runId The unique identifier of the workflow run.
 @return ApiActionsReviewPendingDeploymentsForRunRequest
*/
func (a *ActionsApiService) ActionsReviewPendingDeploymentsForRun(ctx context.Context, owner string, repo string, runId int32) ApiActionsReviewPendingDeploymentsForRunRequest {
	return ApiActionsReviewPendingDeploymentsForRunRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runId: runId,
	}
}

// Execute executes the request
//  @return []Deployment
func (a *ActionsApiService) ActionsReviewPendingDeploymentsForRunExecute(r ApiActionsReviewPendingDeploymentsForRunRequest) ([]Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsReviewPendingDeploymentsForRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run_id"+"}", url.PathEscape(parameterToString(r.runId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsReviewPendingDeploymentsForRunRequest == nil {
		return localVarReturnValue, nil, reportError("actionsReviewPendingDeploymentsForRunRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsReviewPendingDeploymentsForRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	enterprise string
	actionsOidcCustomIssuerPolicyForEnterprise *ActionsOidcCustomIssuerPolicyForEnterprise
}

func (r ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest) ActionsOidcCustomIssuerPolicyForEnterprise(actionsOidcCustomIssuerPolicyForEnterprise ActionsOidcCustomIssuerPolicyForEnterprise) ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest {
	r.actionsOidcCustomIssuerPolicyForEnterprise = &actionsOidcCustomIssuerPolicyForEnterprise
	return r
}

func (r ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetActionsOidcCustomIssuerPolicyForEnterpriseExecute(r)
}

/*
ActionsSetActionsOidcCustomIssuerPolicyForEnterprise Set the GitHub Actions OIDC custom issuer policy for an enterprise

Sets the GitHub Actions OpenID Connect (OIDC) custom issuer policy for an enterprise.
You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id.
 @return ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest
*/
func (a *ActionsApiService) ActionsSetActionsOidcCustomIssuerPolicyForEnterprise(ctx context.Context, enterprise string) ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest {
	return ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest{
		ApiService: a,
		ctx: ctx,
		enterprise: enterprise,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetActionsOidcCustomIssuerPolicyForEnterpriseExecute(r ApiActionsSetActionsOidcCustomIssuerPolicyForEnterpriseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetActionsOidcCustomIssuerPolicyForEnterprise")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/enterprises/{enterprise}/actions/oidc/customization/issuer"
	localVarPath = strings.Replace(localVarPath, "{"+"enterprise"+"}", url.PathEscape(parameterToString(r.enterprise, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsOidcCustomIssuerPolicyForEnterprise == nil {
		return nil, reportError("actionsOidcCustomIssuerPolicyForEnterprise is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsOidcCustomIssuerPolicyForEnterprise
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetAllowedActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	selectedActions *SelectedActions
}

func (r ApiActionsSetAllowedActionsOrganizationRequest) SelectedActions(selectedActions SelectedActions) ApiActionsSetAllowedActionsOrganizationRequest {
	r.selectedActions = &selectedActions
	return r
}

func (r ApiActionsSetAllowedActionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetAllowedActionsOrganizationExecute(r)
}

/*
ActionsSetAllowedActionsOrganization Set allowed actions and reusable workflows for an organization

Sets the actions and reusable workflows that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

If the organization belongs to an enterprise that has `selected` actions and reusable workflows set at the enterprise level, then you cannot override any of the enterprise's allowed actions and reusable workflows settings.

To use the `patterns_allowed` setting for private repositories, the organization must belong to an enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories in the organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsSetAllowedActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsSetAllowedActionsOrganization(ctx context.Context, org string) ApiActionsSetAllowedActionsOrganizationRequest {
	return ApiActionsSetAllowedActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetAllowedActionsOrganizationExecute(r ApiActionsSetAllowedActionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetAllowedActionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/selected-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selectedActions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetAllowedActionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	selectedActions *SelectedActions
}

func (r ApiActionsSetAllowedActionsRepositoryRequest) SelectedActions(selectedActions SelectedActions) ApiActionsSetAllowedActionsRepositoryRequest {
	r.selectedActions = &selectedActions
	return r
}

func (r ApiActionsSetAllowedActionsRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetAllowedActionsRepositoryExecute(r)
}

/*
ActionsSetAllowedActionsRepository Set allowed actions and reusable workflows for a repository

Sets the actions and reusable workflows that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."

If the repository belongs to an organization or enterprise that has `selected` actions and reusable workflows set at the organization or enterprise levels, then you cannot override any of the allowed actions and reusable workflows settings.

To use the `patterns_allowed` setting for private repositories, the repository must belong to an enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsSetAllowedActionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsSetAllowedActionsRepository(ctx context.Context, owner string, repo string) ApiActionsSetAllowedActionsRepositoryRequest {
	return ApiActionsSetAllowedActionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetAllowedActionsRepositoryExecute(r ApiActionsSetAllowedActionsRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetAllowedActionsRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/selected-actions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.selectedActions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerId int32
	enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest *EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
}

func (r ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest) EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest(enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest) ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest {
	r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest = &enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
	return r
}

func (r ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsSetCustomLabelsForSelfHostedRunnerForOrgExecute(r)
}

/*
ActionsSetCustomLabelsForSelfHostedRunnerForOrg Set custom labels for a self-hosted runner for an organization

Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest
*/
func (a *ActionsApiService) ActionsSetCustomLabelsForSelfHostedRunnerForOrg(ctx context.Context, org string, runnerId int32) ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest {
	return ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsSetCustomLabelsForSelfHostedRunnerForOrgExecute(r ApiActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetCustomLabelsForSelfHostedRunnerForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest == nil {
		return localVarReturnValue, nil, reportError("enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	runnerId int32
	enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest *EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
}

func (r ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest) EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest(enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest) ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest {
	r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest = &enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
	return r
}

func (r ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest) Execute() (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	return r.ApiService.ActionsSetCustomLabelsForSelfHostedRunnerForRepoExecute(r)
}

/*
ActionsSetCustomLabelsForSelfHostedRunnerForRepo Set custom labels for a self-hosted runner for a repository

Remove all previous custom labels and set the new custom labels for a specific
self-hosted runner configured in a repository.

You must authenticate using an access token with the `repo` scope to use this
endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param runnerId Unique identifier of the self-hosted runner.
 @return ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest
*/
func (a *ActionsApiService) ActionsSetCustomLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner string, repo string, runnerId int32) ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest {
	return ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		runnerId: runnerId,
	}
}

// Execute executes the request
//  @return EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
func (a *ActionsApiService) ActionsSetCustomLabelsForSelfHostedRunnerForRepoExecute(r ApiActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest) (*EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetCustomLabelsForSelfHostedRunnerForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_id"+"}", url.PathEscape(parameterToString(r.runnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest == nil {
		return localVarReturnValue, nil, reportError("enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsSetCustomOidcSubClaimForRepoRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	optOutOidcCustomSub *OptOutOidcCustomSub
}

func (r ApiActionsSetCustomOidcSubClaimForRepoRequest) OptOutOidcCustomSub(optOutOidcCustomSub OptOutOidcCustomSub) ApiActionsSetCustomOidcSubClaimForRepoRequest {
	r.optOutOidcCustomSub = &optOutOidcCustomSub
	return r
}

func (r ApiActionsSetCustomOidcSubClaimForRepoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActionsSetCustomOidcSubClaimForRepoExecute(r)
}

/*
ActionsSetCustomOidcSubClaimForRepo Set the opt-out flag of an OIDC subject claim customization for a repository

Sets the `opt-out` flag of a GitHub Actions OpenID Connect (OIDC) subject claim customization for a repository.
You must authenticate using an access token with the `repo` scope to use this
endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsSetCustomOidcSubClaimForRepoRequest
*/
func (a *ActionsApiService) ActionsSetCustomOidcSubClaimForRepo(ctx context.Context, owner string, repo string) ApiActionsSetCustomOidcSubClaimForRepoRequest {
	return ApiActionsSetCustomOidcSubClaimForRepoRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActionsApiService) ActionsSetCustomOidcSubClaimForRepoExecute(r ApiActionsSetCustomOidcSubClaimForRepoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetCustomOidcSubClaimForRepo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/oidc/customization/sub"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.optOutOidcCustomSub == nil {
		return localVarReturnValue, nil, reportError("optOutOidcCustomSub is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/scim+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.optOutOidcCustomSub
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationErrorSimple
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	enterprise string
	actionsSetDefaultWorkflowPermissions *ActionsSetDefaultWorkflowPermissions
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest) ActionsSetDefaultWorkflowPermissions(actionsSetDefaultWorkflowPermissions ActionsSetDefaultWorkflowPermissions) ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest {
	r.actionsSetDefaultWorkflowPermissions = &actionsSetDefaultWorkflowPermissions
	return r
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseExecute(r)
}

/*
ActionsSetGithubActionsDefaultWorkflowPermissionsEnterprise Set default workflow permissions for an enterprise

Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an enterprise, and sets
whether GitHub Actions can submit approving pull request reviews. For more information, see
"[Enforcing a policy for workflow permissions in your enterprise](https://docs.github.com/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-workflow-permissions-in-your-enterprise)."

You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
GitHub Apps must have the `enterprise_administration:write` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id.
 @return ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest
*/
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise string) ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest {
	return ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest{
		ApiService: a,
		ctx: ctx,
		enterprise: enterprise,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseExecute(r ApiActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsEnterprise")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/enterprises/{enterprise}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"enterprise"+"}", url.PathEscape(parameterToString(r.enterprise, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetDefaultWorkflowPermissions == nil {
		return nil, reportError("actionsSetDefaultWorkflowPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetDefaultWorkflowPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	actionsSetDefaultWorkflowPermissions *ActionsSetDefaultWorkflowPermissions
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest) ActionsSetDefaultWorkflowPermissions(actionsSetDefaultWorkflowPermissions ActionsSetDefaultWorkflowPermissions) ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest {
	r.actionsSetDefaultWorkflowPermissions = &actionsSetDefaultWorkflowPermissions
	return r
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationExecute(r)
}

/*
ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization Set default workflow permissions for an organization

Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions
can submit approving pull request reviews. For more information, see
"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org string) ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest {
	return ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationExecute(r ApiActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetDefaultWorkflowPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	actionsSetDefaultWorkflowPermissions *ActionsSetDefaultWorkflowPermissions
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest) ActionsSetDefaultWorkflowPermissions(actionsSetDefaultWorkflowPermissions ActionsSetDefaultWorkflowPermissions) ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest {
	r.actionsSetDefaultWorkflowPermissions = &actionsSetDefaultWorkflowPermissions
	return r
}

func (r ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryExecute(r)
}

/*
ActionsSetGithubActionsDefaultWorkflowPermissionsRepository Set default workflow permissions for a repository

Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions
can submit approving pull request reviews.
For more information, see "[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner string, repo string) ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest {
	return ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryExecute(r ApiActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetGithubActionsDefaultWorkflowPermissionsRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetDefaultWorkflowPermissions == nil {
		return nil, reportError("actionsSetDefaultWorkflowPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetDefaultWorkflowPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetGithubActionsPermissionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	actionsSetGithubActionsPermissionsOrganizationRequest *ActionsSetGithubActionsPermissionsOrganizationRequest
}

func (r ApiActionsSetGithubActionsPermissionsOrganizationRequest) ActionsSetGithubActionsPermissionsOrganizationRequest(actionsSetGithubActionsPermissionsOrganizationRequest ActionsSetGithubActionsPermissionsOrganizationRequest) ApiActionsSetGithubActionsPermissionsOrganizationRequest {
	r.actionsSetGithubActionsPermissionsOrganizationRequest = &actionsSetGithubActionsPermissionsOrganizationRequest
	return r
}

func (r ApiActionsSetGithubActionsPermissionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetGithubActionsPermissionsOrganizationExecute(r)
}

/*
ActionsSetGithubActionsPermissionsOrganization Set GitHub Actions permissions for an organization

Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable workflows in an organization.

If the organization belongs to an enterprise that has set restrictive permissions at the enterprise level, such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot override them for the organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsSetGithubActionsPermissionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, org string) ApiActionsSetGithubActionsPermissionsOrganizationRequest {
	return ApiActionsSetGithubActionsPermissionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetGithubActionsPermissionsOrganizationExecute(r ApiActionsSetGithubActionsPermissionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetGithubActionsPermissionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetGithubActionsPermissionsOrganizationRequest == nil {
		return nil, reportError("actionsSetGithubActionsPermissionsOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetGithubActionsPermissionsOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetGithubActionsPermissionsRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	actionsSetGithubActionsPermissionsRepositoryRequest *ActionsSetGithubActionsPermissionsRepositoryRequest
}

func (r ApiActionsSetGithubActionsPermissionsRepositoryRequest) ActionsSetGithubActionsPermissionsRepositoryRequest(actionsSetGithubActionsPermissionsRepositoryRequest ActionsSetGithubActionsPermissionsRepositoryRequest) ApiActionsSetGithubActionsPermissionsRepositoryRequest {
	r.actionsSetGithubActionsPermissionsRepositoryRequest = &actionsSetGithubActionsPermissionsRepositoryRequest
	return r
}

func (r ApiActionsSetGithubActionsPermissionsRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetGithubActionsPermissionsRepositoryExecute(r)
}

/*
ActionsSetGithubActionsPermissionsRepository Set GitHub Actions permissions for a repository

Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions and reusable workflows in the repository.

If the repository belongs to an organization or enterprise that has set restrictive permissions at the organization or enterprise levels, such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot override them for the repository.

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsSetGithubActionsPermissionsRepositoryRequest
*/
func (a *ActionsApiService) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, owner string, repo string) ApiActionsSetGithubActionsPermissionsRepositoryRequest {
	return ApiActionsSetGithubActionsPermissionsRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetGithubActionsPermissionsRepositoryExecute(r ApiActionsSetGithubActionsPermissionsRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetGithubActionsPermissionsRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetGithubActionsPermissionsRepositoryRequest == nil {
		return nil, reportError("actionsSetGithubActionsPermissionsRepositoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetGithubActionsPermissionsRepositoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest
}

func (r ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest) ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	r.actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest = &actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest
	return r
}

func (r ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgExecute(r)
}

/*
ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg Set repository access for a self-hosted runner group in an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest
*/
func (a *ActionsApiService) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest {
	return ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgExecute(r ApiActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest == nil {
		return nil, reportError("actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetSelectedReposForOrgSecretRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	secretName string
	actionsSetSelectedReposForOrgSecretRequest *ActionsSetSelectedReposForOrgSecretRequest
}

func (r ApiActionsSetSelectedReposForOrgSecretRequest) ActionsSetSelectedReposForOrgSecretRequest(actionsSetSelectedReposForOrgSecretRequest ActionsSetSelectedReposForOrgSecretRequest) ApiActionsSetSelectedReposForOrgSecretRequest {
	r.actionsSetSelectedReposForOrgSecretRequest = &actionsSetSelectedReposForOrgSecretRequest
	return r
}

func (r ApiActionsSetSelectedReposForOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetSelectedReposForOrgSecretExecute(r)
}

/*
ActionsSetSelectedReposForOrgSecret Set selected repositories for an organization secret

Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiActionsSetSelectedReposForOrgSecretRequest
*/
func (a *ActionsApiService) ActionsSetSelectedReposForOrgSecret(ctx context.Context, org string, secretName string) ApiActionsSetSelectedReposForOrgSecretRequest {
	return ApiActionsSetSelectedReposForOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetSelectedReposForOrgSecretExecute(r ApiActionsSetSelectedReposForOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetSelectedReposForOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/secrets/{secret_name}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetSelectedReposForOrgSecretRequest == nil {
		return nil, reportError("actionsSetSelectedReposForOrgSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetSelectedReposForOrgSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest
}

func (r ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest) ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
	r.actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest = &actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest
	return r
}

func (r ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationExecute(r)
}

/*
ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization Set selected repositories enabled for GitHub Actions in an organization

Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."

You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest
*/
func (a *ActionsApiService) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org string) ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest {
	return ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationExecute(r ApiActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/permissions/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest == nil {
		return nil, reportError("actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetSelfHostedRunnersInGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest
}

func (r ApiActionsSetSelfHostedRunnersInGroupForOrgRequest) EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest) ApiActionsSetSelfHostedRunnersInGroupForOrgRequest {
	r.enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest = &enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest
	return r
}

func (r ApiActionsSetSelfHostedRunnersInGroupForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetSelfHostedRunnersInGroupForOrgExecute(r)
}

/*
ActionsSetSelfHostedRunnersInGroupForOrg Set self-hosted runners in a group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Replaces the list of self-hosted runners that are part of an organization runner group.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsSetSelfHostedRunnersInGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsSetSelfHostedRunnersInGroupForOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsSetSelfHostedRunnersInGroupForOrgRequest {
	return ApiActionsSetSelfHostedRunnersInGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetSelfHostedRunnersInGroupForOrgExecute(r ApiActionsSetSelfHostedRunnersInGroupForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetSelfHostedRunnersInGroupForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest == nil {
		return nil, reportError("enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsSetWorkflowAccessToRepositoryRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	owner string
	repo string
	actionsWorkflowAccessToRepository *ActionsWorkflowAccessToRepository
}

func (r ApiActionsSetWorkflowAccessToRepositoryRequest) ActionsWorkflowAccessToRepository(actionsWorkflowAccessToRepository ActionsWorkflowAccessToRepository) ApiActionsSetWorkflowAccessToRepositoryRequest {
	r.actionsWorkflowAccessToRepository = &actionsWorkflowAccessToRepository
	return r
}

func (r ApiActionsSetWorkflowAccessToRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionsSetWorkflowAccessToRepositoryExecute(r)
}

/*
ActionsSetWorkflowAccessToRepository Set the level of access for workflows outside of the repository

Sets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.
This endpoint only applies to internal repositories. For more information, see "[Managing GitHub Actions settings for a repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-an-internal-repository)."

You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
repository `administration` permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiActionsSetWorkflowAccessToRepositoryRequest
*/
func (a *ActionsApiService) ActionsSetWorkflowAccessToRepository(ctx context.Context, owner string, repo string) ApiActionsSetWorkflowAccessToRepositoryRequest {
	return ApiActionsSetWorkflowAccessToRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *ActionsApiService) ActionsSetWorkflowAccessToRepositoryExecute(r ApiActionsSetWorkflowAccessToRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsSetWorkflowAccessToRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/actions/permissions/access"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsWorkflowAccessToRepository == nil {
		return nil, reportError("actionsWorkflowAccessToRepository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsWorkflowAccessToRepository
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest struct {
	ctx context.Context
	ApiService *ActionsApiService
	org string
	runnerGroupId int32
	actionsUpdateSelfHostedRunnerGroupForOrgRequest *ActionsUpdateSelfHostedRunnerGroupForOrgRequest
}

func (r ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest) ActionsUpdateSelfHostedRunnerGroupForOrgRequest(actionsUpdateSelfHostedRunnerGroupForOrgRequest ActionsUpdateSelfHostedRunnerGroupForOrgRequest) ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest {
	r.actionsUpdateSelfHostedRunnerGroupForOrgRequest = &actionsUpdateSelfHostedRunnerGroupForOrgRequest
	return r
}

func (r ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest) Execute() (*RunnerGroupsOrg, *http.Response, error) {
	return r.ApiService.ActionsUpdateSelfHostedRunnerGroupForOrgExecute(r)
}

/*
ActionsUpdateSelfHostedRunnerGroupForOrg Update a self-hosted runner group for an organization

The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."

Updates the `name` and `visibility` of a self-hosted runner group in an organization.

You must authenticate using an access token with the `admin:org` scope to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param runnerGroupId Unique identifier of the self-hosted runner group.
 @return ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest
*/
func (a *ActionsApiService) ActionsUpdateSelfHostedRunnerGroupForOrg(ctx context.Context, org string, runnerGroupId int32) ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest {
	return ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		runnerGroupId: runnerGroupId,
	}
}

// Execute executes the request
//  @return RunnerGroupsOrg
func (a *ActionsApiService) ActionsUpdateSelfHostedRunnerGroupForOrgExecute(r ApiActionsUpdateSelfHostedRunnerGroupForOrgRequest) (*RunnerGroupsOrg, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RunnerGroupsOrg
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsApiService.ActionsUpdateSelfHostedRunnerGroupForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/actions/runner-groups/{runner_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runner_group_id"+"}", url.PathEscape(parameterToString(r.runnerGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actionsUpdateSelfHostedRunnerGroupForOrgRequest == nil {
		return localVarReturnValue, nil, reportError("actionsUpdateSelfHostedRunnerGroupForOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.actionsUpdateSelfHostedRunnerGroupForOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
