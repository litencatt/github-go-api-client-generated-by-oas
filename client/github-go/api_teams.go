/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// TeamsApiService TeamsApi service
type TeamsApiService service

type ApiTeamsAddMemberLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
}

func (r ApiTeamsAddMemberLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsAddMemberLegacyExecute(r)
}

/*
TeamsAddMemberLegacy Add team member (Legacy)

The "Add team member" endpoint (described below) is deprecated.

We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsAddMemberLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsAddMemberLegacy(ctx context.Context, teamId int32, username string) ApiTeamsAddMemberLegacyRequest {
	return ApiTeamsAddMemberLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsAddMemberLegacyExecute(r ApiTeamsAddMemberLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddMemberLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/members/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateMembershipForUserInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	username string
	teamsAddOrUpdateMembershipForUserInOrgRequest *TeamsAddOrUpdateMembershipForUserInOrgRequest
}

func (r ApiTeamsAddOrUpdateMembershipForUserInOrgRequest) TeamsAddOrUpdateMembershipForUserInOrgRequest(teamsAddOrUpdateMembershipForUserInOrgRequest TeamsAddOrUpdateMembershipForUserInOrgRequest) ApiTeamsAddOrUpdateMembershipForUserInOrgRequest {
	r.teamsAddOrUpdateMembershipForUserInOrgRequest = &teamsAddOrUpdateMembershipForUserInOrgRequest
	return r
}

func (r ApiTeamsAddOrUpdateMembershipForUserInOrgRequest) Execute() (*TeamMembership, *http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateMembershipForUserInOrgExecute(r)
}

/*
TeamsAddOrUpdateMembershipForUserInOrg Add or update team membership for a user

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param username The handle for the GitHub user account.
 @return ApiTeamsAddOrUpdateMembershipForUserInOrgRequest
*/
func (a *TeamsApiService) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, org string, teamSlug string, username string) ApiTeamsAddOrUpdateMembershipForUserInOrgRequest {
	return ApiTeamsAddOrUpdateMembershipForUserInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		username: username,
	}
}

// Execute executes the request
//  @return TeamMembership
func (a *TeamsApiService) TeamsAddOrUpdateMembershipForUserInOrgExecute(r ApiTeamsAddOrUpdateMembershipForUserInOrgRequest) (*TeamMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateMembershipForUserInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateMembershipForUserInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateMembershipForUserLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
	teamsAddOrUpdateMembershipForUserInOrgRequest *TeamsAddOrUpdateMembershipForUserInOrgRequest
}

func (r ApiTeamsAddOrUpdateMembershipForUserLegacyRequest) TeamsAddOrUpdateMembershipForUserInOrgRequest(teamsAddOrUpdateMembershipForUserInOrgRequest TeamsAddOrUpdateMembershipForUserInOrgRequest) ApiTeamsAddOrUpdateMembershipForUserLegacyRequest {
	r.teamsAddOrUpdateMembershipForUserInOrgRequest = &teamsAddOrUpdateMembershipForUserInOrgRequest
	return r
}

func (r ApiTeamsAddOrUpdateMembershipForUserLegacyRequest) Execute() (*TeamMembership, *http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateMembershipForUserLegacyExecute(r)
}

/*
TeamsAddOrUpdateMembershipForUserLegacy Add or update team membership for a user (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.

If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsAddOrUpdateMembershipForUserLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, teamId int32, username string) ApiTeamsAddOrUpdateMembershipForUserLegacyRequest {
	return ApiTeamsAddOrUpdateMembershipForUserLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
//  @return TeamMembership
// Deprecated
func (a *TeamsApiService) TeamsAddOrUpdateMembershipForUserLegacyExecute(r ApiTeamsAddOrUpdateMembershipForUserLegacyRequest) (*TeamMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateMembershipForUserLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateMembershipForUserInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	projectId int32
	teamsAddOrUpdateProjectPermissionsInOrgRequest *TeamsAddOrUpdateProjectPermissionsInOrgRequest
}

func (r ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest) TeamsAddOrUpdateProjectPermissionsInOrgRequest(teamsAddOrUpdateProjectPermissionsInOrgRequest TeamsAddOrUpdateProjectPermissionsInOrgRequest) ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest {
	r.teamsAddOrUpdateProjectPermissionsInOrgRequest = &teamsAddOrUpdateProjectPermissionsInOrgRequest
	return r
}

func (r ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateProjectPermissionsInOrgExecute(r)
}

/*
TeamsAddOrUpdateProjectPermissionsInOrg Add or update team project permissions

Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/projects/{project_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param projectId The unique identifier of the project.
 @return ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest
*/
func (a *TeamsApiService) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, org string, teamSlug string, projectId int32) ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest {
	return ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsAddOrUpdateProjectPermissionsInOrgExecute(r ApiTeamsAddOrUpdateProjectPermissionsInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateProjectPermissionsInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateProjectPermissionsInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v OrgsRemoveOutsideCollaborator422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	projectId int32
	teamsAddOrUpdateProjectPermissionsLegacyRequest *TeamsAddOrUpdateProjectPermissionsLegacyRequest
}

func (r ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest) TeamsAddOrUpdateProjectPermissionsLegacyRequest(teamsAddOrUpdateProjectPermissionsLegacyRequest TeamsAddOrUpdateProjectPermissionsLegacyRequest) ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest {
	r.teamsAddOrUpdateProjectPermissionsLegacyRequest = &teamsAddOrUpdateProjectPermissionsLegacyRequest
	return r
}

func (r ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateProjectPermissionsLegacyExecute(r)
}

/*
TeamsAddOrUpdateProjectPermissionsLegacy Add or update team project permissions (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions) endpoint.

Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param projectId The unique identifier of the project.
 @return ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, teamId int32, projectId int32) ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest {
	return ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		projectId: projectId,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsAddOrUpdateProjectPermissionsLegacyExecute(r ApiTeamsAddOrUpdateProjectPermissionsLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateProjectPermissionsLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateProjectPermissionsLegacyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v OrgsRemoveOutsideCollaborator422Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	owner string
	repo string
	teamsAddOrUpdateRepoPermissionsInOrgRequest *TeamsAddOrUpdateRepoPermissionsInOrgRequest
}

func (r ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest) TeamsAddOrUpdateRepoPermissionsInOrgRequest(teamsAddOrUpdateRepoPermissionsInOrgRequest TeamsAddOrUpdateRepoPermissionsInOrgRequest) ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest {
	r.teamsAddOrUpdateRepoPermissionsInOrgRequest = &teamsAddOrUpdateRepoPermissionsInOrgRequest
	return r
}

func (r ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateRepoPermissionsInOrgExecute(r)
}

/*
TeamsAddOrUpdateRepoPermissionsInOrg Add or update team repository permissions

To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.

For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest
*/
func (a *TeamsApiService) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, org string, teamSlug string, owner string, repo string) ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest {
	return ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsAddOrUpdateRepoPermissionsInOrgExecute(r ApiTeamsAddOrUpdateRepoPermissionsInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateRepoPermissionsInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateRepoPermissionsInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	owner string
	repo string
	teamsAddOrUpdateRepoPermissionsLegacyRequest *TeamsAddOrUpdateRepoPermissionsLegacyRequest
}

func (r ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest) TeamsAddOrUpdateRepoPermissionsLegacyRequest(teamsAddOrUpdateRepoPermissionsLegacyRequest TeamsAddOrUpdateRepoPermissionsLegacyRequest) ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest {
	r.teamsAddOrUpdateRepoPermissionsLegacyRequest = &teamsAddOrUpdateRepoPermissionsLegacyRequest
	return r
}

func (r ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsAddOrUpdateRepoPermissionsLegacyExecute(r)
}

/*
TeamsAddOrUpdateRepoPermissionsLegacy Add or update team repository permissions (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.

To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.

Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, teamId int32, owner string, repo string) ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest {
	return ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsAddOrUpdateRepoPermissionsLegacyExecute(r ApiTeamsAddOrUpdateRepoPermissionsLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsAddOrUpdateRepoPermissionsLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsAddOrUpdateRepoPermissionsLegacyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsCheckPermissionsForProjectInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	projectId int32
}

func (r ApiTeamsCheckPermissionsForProjectInOrgRequest) Execute() (*TeamProject, *http.Response, error) {
	return r.ApiService.TeamsCheckPermissionsForProjectInOrgExecute(r)
}

/*
TeamsCheckPermissionsForProjectInOrg Check team permissions for a project

Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects/{project_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param projectId The unique identifier of the project.
 @return ApiTeamsCheckPermissionsForProjectInOrgRequest
*/
func (a *TeamsApiService) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, org string, teamSlug string, projectId int32) ApiTeamsCheckPermissionsForProjectInOrgRequest {
	return ApiTeamsCheckPermissionsForProjectInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return TeamProject
func (a *TeamsApiService) TeamsCheckPermissionsForProjectInOrgExecute(r ApiTeamsCheckPermissionsForProjectInOrgRequest) (*TeamProject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCheckPermissionsForProjectInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCheckPermissionsForProjectLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	projectId int32
}

func (r ApiTeamsCheckPermissionsForProjectLegacyRequest) Execute() (*TeamProject, *http.Response, error) {
	return r.ApiService.TeamsCheckPermissionsForProjectLegacyExecute(r)
}

/*
TeamsCheckPermissionsForProjectLegacy Check team permissions for a project (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project) endpoint.

Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param projectId The unique identifier of the project.
 @return ApiTeamsCheckPermissionsForProjectLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, teamId int32, projectId int32) ApiTeamsCheckPermissionsForProjectLegacyRequest {
	return ApiTeamsCheckPermissionsForProjectLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return TeamProject
// Deprecated
func (a *TeamsApiService) TeamsCheckPermissionsForProjectLegacyExecute(r ApiTeamsCheckPermissionsForProjectLegacyRequest) (*TeamProject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCheckPermissionsForProjectLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCheckPermissionsForRepoInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	owner string
	repo string
}

func (r ApiTeamsCheckPermissionsForRepoInOrgRequest) Execute() (*TeamRepository, *http.Response, error) {
	return r.ApiService.TeamsCheckPermissionsForRepoInOrgExecute(r)
}

/*
TeamsCheckPermissionsForRepoInOrg Check team permissions for a repository

Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.

If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsCheckPermissionsForRepoInOrgRequest
*/
func (a *TeamsApiService) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, org string, teamSlug string, owner string, repo string) ApiTeamsCheckPermissionsForRepoInOrgRequest {
	return ApiTeamsCheckPermissionsForRepoInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return TeamRepository
func (a *TeamsApiService) TeamsCheckPermissionsForRepoInOrgExecute(r ApiTeamsCheckPermissionsForRepoInOrgRequest) (*TeamRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCheckPermissionsForRepoInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCheckPermissionsForRepoLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	owner string
	repo string
}

func (r ApiTeamsCheckPermissionsForRepoLegacyRequest) Execute() (*TeamRepository, *http.Response, error) {
	return r.ApiService.TeamsCheckPermissionsForRepoLegacyExecute(r)
}

/*
TeamsCheckPermissionsForRepoLegacy Check team permissions for a repository (Legacy)

**Note**: Repositories inherited through a parent team will also be checked.

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.

You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsCheckPermissionsForRepoLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, teamId int32, owner string, repo string) ApiTeamsCheckPermissionsForRepoLegacyRequest {
	return ApiTeamsCheckPermissionsForRepoLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return TeamRepository
// Deprecated
func (a *TeamsApiService) TeamsCheckPermissionsForRepoLegacyExecute(r ApiTeamsCheckPermissionsForRepoLegacyRequest) (*TeamRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCheckPermissionsForRepoLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamsCreateRequest *TeamsCreateRequest
}

func (r ApiTeamsCreateRequest) TeamsCreateRequest(teamsCreateRequest TeamsCreateRequest) ApiTeamsCreateRequest {
	r.teamsCreateRequest = &teamsCreateRequest
	return r
}

func (r ApiTeamsCreateRequest) Execute() (*TeamFull, *http.Response, error) {
	return r.ApiService.TeamsCreateExecute(r)
}

/*
TeamsCreate Create a team

To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://docs.github.com/en/articles/setting-team-creation-permissions-in-your-organization)."

When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://docs.github.com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiTeamsCreateRequest
*/
func (a *TeamsApiService) TeamsCreate(ctx context.Context, org string) ApiTeamsCreateRequest {
	return ApiTeamsCreateRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return TeamFull
func (a *TeamsApiService) TeamsCreateExecute(r ApiTeamsCreateRequest) (*TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	teamsCreateDiscussionCommentInOrgRequest *TeamsCreateDiscussionCommentInOrgRequest
}

func (r ApiTeamsCreateDiscussionCommentInOrgRequest) TeamsCreateDiscussionCommentInOrgRequest(teamsCreateDiscussionCommentInOrgRequest TeamsCreateDiscussionCommentInOrgRequest) ApiTeamsCreateDiscussionCommentInOrgRequest {
	r.teamsCreateDiscussionCommentInOrgRequest = &teamsCreateDiscussionCommentInOrgRequest
	return r
}

func (r ApiTeamsCreateDiscussionCommentInOrgRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsCreateDiscussionCommentInOrgExecute(r)
}

/*
TeamsCreateDiscussionCommentInOrg Create a discussion comment

Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsCreateDiscussionCommentInOrgRequest
*/
func (a *TeamsApiService) TeamsCreateDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiTeamsCreateDiscussionCommentInOrgRequest {
	return ApiTeamsCreateDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
func (a *TeamsApiService) TeamsCreateDiscussionCommentInOrgExecute(r ApiTeamsCreateDiscussionCommentInOrgRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateDiscussionCommentInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	teamsCreateDiscussionCommentInOrgRequest *TeamsCreateDiscussionCommentInOrgRequest
}

func (r ApiTeamsCreateDiscussionCommentLegacyRequest) TeamsCreateDiscussionCommentInOrgRequest(teamsCreateDiscussionCommentInOrgRequest TeamsCreateDiscussionCommentInOrgRequest) ApiTeamsCreateDiscussionCommentLegacyRequest {
	r.teamsCreateDiscussionCommentInOrgRequest = &teamsCreateDiscussionCommentInOrgRequest
	return r
}

func (r ApiTeamsCreateDiscussionCommentLegacyRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsCreateDiscussionCommentLegacyExecute(r)
}

/*
TeamsCreateDiscussionCommentLegacy Create a discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.

Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsCreateDiscussionCommentLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsCreateDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiTeamsCreateDiscussionCommentLegacyRequest {
	return ApiTeamsCreateDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
// Deprecated
func (a *TeamsApiService) TeamsCreateDiscussionCommentLegacyExecute(r ApiTeamsCreateDiscussionCommentLegacyRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateDiscussionCommentLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	teamsCreateDiscussionInOrgRequest *TeamsCreateDiscussionInOrgRequest
}

func (r ApiTeamsCreateDiscussionInOrgRequest) TeamsCreateDiscussionInOrgRequest(teamsCreateDiscussionInOrgRequest TeamsCreateDiscussionInOrgRequest) ApiTeamsCreateDiscussionInOrgRequest {
	r.teamsCreateDiscussionInOrgRequest = &teamsCreateDiscussionInOrgRequest
	return r
}

func (r ApiTeamsCreateDiscussionInOrgRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsCreateDiscussionInOrgExecute(r)
}

/*
TeamsCreateDiscussionInOrg Create a discussion

Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsCreateDiscussionInOrgRequest
*/
func (a *TeamsApiService) TeamsCreateDiscussionInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsCreateDiscussionInOrgRequest {
	return ApiTeamsCreateDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return TeamDiscussion
func (a *TeamsApiService) TeamsCreateDiscussionInOrgExecute(r ApiTeamsCreateDiscussionInOrgRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateDiscussionInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	teamsCreateDiscussionInOrgRequest *TeamsCreateDiscussionInOrgRequest
}

func (r ApiTeamsCreateDiscussionLegacyRequest) TeamsCreateDiscussionInOrgRequest(teamsCreateDiscussionInOrgRequest TeamsCreateDiscussionInOrgRequest) ApiTeamsCreateDiscussionLegacyRequest {
	r.teamsCreateDiscussionInOrgRequest = &teamsCreateDiscussionInOrgRequest
	return r
}

func (r ApiTeamsCreateDiscussionLegacyRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsCreateDiscussionLegacyExecute(r)
}

/*
TeamsCreateDiscussionLegacy Create a discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/reference/teams#create-a-discussion) endpoint.

Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsCreateDiscussionLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsCreateDiscussionLegacy(ctx context.Context, teamId int32) ApiTeamsCreateDiscussionLegacyRequest {
	return ApiTeamsCreateDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return TeamDiscussion
// Deprecated
func (a *TeamsApiService) TeamsCreateDiscussionLegacyExecute(r ApiTeamsCreateDiscussionLegacyRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateDiscussionLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest *TeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest
}

func (r ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest) TeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest TeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest) ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest {
	r.teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest = &teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest
	return r
}

func (r ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest) Execute() (*GroupMapping, *http.Response, error) {
	return r.ApiService.TeamsCreateOrUpdateIdpGroupConnectionsInOrgExecute(r)
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsInOrg Create or update IdP group connections

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest
*/
func (a *TeamsApiService) TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest {
	return ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return GroupMapping
func (a *TeamsApiService) TeamsCreateOrUpdateIdpGroupConnectionsInOrgExecute(r ApiTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest) (*GroupMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateOrUpdateIdpGroupConnectionsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateOrUpdateIdpGroupConnectionsInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest *TeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest
}

func (r ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest) TeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest TeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest) ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest {
	r.teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest = &teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest
	return r
}

func (r ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest) Execute() (*GroupMapping, *http.Response, error) {
	return r.ApiService.TeamsCreateOrUpdateIdpGroupConnectionsLegacyExecute(r)
}

/*
TeamsCreateOrUpdateIdpGroupConnectionsLegacy Create or update IdP group connections (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create or update IdP group connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, teamId int32) ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest {
	return ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return GroupMapping
// Deprecated
func (a *TeamsApiService) TeamsCreateOrUpdateIdpGroupConnectionsLegacyExecute(r ApiTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest) (*GroupMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsCreateOrUpdateIdpGroupConnectionsLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/team-sync/group-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateOrUpdateIdpGroupConnectionsLegacyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsDeleteDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
}

func (r ApiTeamsDeleteDiscussionCommentInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteDiscussionCommentInOrgExecute(r)
}

/*
TeamsDeleteDiscussionCommentInOrg Delete a discussion comment

Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsDeleteDiscussionCommentInOrgRequest
*/
func (a *TeamsApiService) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32) ApiTeamsDeleteDiscussionCommentInOrgRequest {
	return ApiTeamsDeleteDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsDeleteDiscussionCommentInOrgExecute(r ApiTeamsDeleteDiscussionCommentInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteDiscussionCommentInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeleteDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	commentNumber int32
}

func (r ApiTeamsDeleteDiscussionCommentLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteDiscussionCommentLegacyExecute(r)
}

/*
TeamsDeleteDiscussionCommentLegacy Delete a discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.

Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsDeleteDiscussionCommentLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32, commentNumber int32) ApiTeamsDeleteDiscussionCommentLegacyRequest {
	return ApiTeamsDeleteDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsDeleteDiscussionCommentLegacyExecute(r ApiTeamsDeleteDiscussionCommentLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteDiscussionCommentLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeleteDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
}

func (r ApiTeamsDeleteDiscussionInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteDiscussionInOrgExecute(r)
}

/*
TeamsDeleteDiscussionInOrg Delete a discussion

Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsDeleteDiscussionInOrgRequest
*/
func (a *TeamsApiService) TeamsDeleteDiscussionInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiTeamsDeleteDiscussionInOrgRequest {
	return ApiTeamsDeleteDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsDeleteDiscussionInOrgExecute(r ApiTeamsDeleteDiscussionInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteDiscussionInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeleteDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
}

func (r ApiTeamsDeleteDiscussionLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteDiscussionLegacyExecute(r)
}

/*
TeamsDeleteDiscussionLegacy Delete a discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/reference/teams#delete-a-discussion) endpoint.

Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsDeleteDiscussionLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsDeleteDiscussionLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiTeamsDeleteDiscussionLegacyRequest {
	return ApiTeamsDeleteDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsDeleteDiscussionLegacyExecute(r ApiTeamsDeleteDiscussionLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteDiscussionLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeleteInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
}

func (r ApiTeamsDeleteInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteInOrgExecute(r)
}

/*
TeamsDeleteInOrg Delete a team

To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsDeleteInOrgRequest
*/
func (a *TeamsApiService) TeamsDeleteInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsDeleteInOrgRequest {
	return ApiTeamsDeleteInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsDeleteInOrgExecute(r ApiTeamsDeleteInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsDeleteLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
}

func (r ApiTeamsDeleteLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsDeleteLegacyExecute(r)
}

/*
TeamsDeleteLegacy Delete a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/reference/teams#delete-a-team) endpoint.

To delete a team, the authenticated user must be an organization owner or team maintainer.

If you are an organization owner, deleting a parent team will delete all of its child teams as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsDeleteLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsDeleteLegacy(ctx context.Context, teamId int32) ApiTeamsDeleteLegacyRequest {
	return ApiTeamsDeleteLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsDeleteLegacyExecute(r ApiTeamsDeleteLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsDeleteLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsExternalIdpGroupInfoForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	groupId int32
}

func (r ApiTeamsExternalIdpGroupInfoForOrgRequest) Execute() (*ExternalGroup, *http.Response, error) {
	return r.ApiService.TeamsExternalIdpGroupInfoForOrgExecute(r)
}

/*
TeamsExternalIdpGroupInfoForOrg Get an external group

Displays information about the specific group's usage.  Provides a list of the group's external members as well as a list of teams that this group is connected to.

You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param groupId The unique identifier of the group.
 @return ApiTeamsExternalIdpGroupInfoForOrgRequest
*/
func (a *TeamsApiService) TeamsExternalIdpGroupInfoForOrg(ctx context.Context, org string, groupId int32) ApiTeamsExternalIdpGroupInfoForOrgRequest {
	return ApiTeamsExternalIdpGroupInfoForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return ExternalGroup
func (a *TeamsApiService) TeamsExternalIdpGroupInfoForOrgExecute(r ApiTeamsExternalIdpGroupInfoForOrgRequest) (*ExternalGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsExternalIdpGroupInfoForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/external-group/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetByNameRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
}

func (r ApiTeamsGetByNameRequest) Execute() (*TeamFull, *http.Response, error) {
	return r.ApiService.TeamsGetByNameExecute(r)
}

/*
TeamsGetByName Get a team by name

Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsGetByNameRequest
*/
func (a *TeamsApiService) TeamsGetByName(ctx context.Context, org string, teamSlug string) ApiTeamsGetByNameRequest {
	return ApiTeamsGetByNameRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return TeamFull
func (a *TeamsApiService) TeamsGetByNameExecute(r ApiTeamsGetByNameRequest) (*TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
}

func (r ApiTeamsGetDiscussionCommentInOrgRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsGetDiscussionCommentInOrgExecute(r)
}

/*
TeamsGetDiscussionCommentInOrg Get a discussion comment

Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsGetDiscussionCommentInOrgRequest
*/
func (a *TeamsApiService) TeamsGetDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32) ApiTeamsGetDiscussionCommentInOrgRequest {
	return ApiTeamsGetDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
func (a *TeamsApiService) TeamsGetDiscussionCommentInOrgExecute(r ApiTeamsGetDiscussionCommentInOrgRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetDiscussionCommentInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	commentNumber int32
}

func (r ApiTeamsGetDiscussionCommentLegacyRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsGetDiscussionCommentLegacyExecute(r)
}

/*
TeamsGetDiscussionCommentLegacy Get a discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/reference/teams#get-a-discussion-comment) endpoint.

Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsGetDiscussionCommentLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsGetDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32, commentNumber int32) ApiTeamsGetDiscussionCommentLegacyRequest {
	return ApiTeamsGetDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
// Deprecated
func (a *TeamsApiService) TeamsGetDiscussionCommentLegacyExecute(r ApiTeamsGetDiscussionCommentLegacyRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetDiscussionCommentLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
}

func (r ApiTeamsGetDiscussionInOrgRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsGetDiscussionInOrgExecute(r)
}

/*
TeamsGetDiscussionInOrg Get a discussion

Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsGetDiscussionInOrgRequest
*/
func (a *TeamsApiService) TeamsGetDiscussionInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiTeamsGetDiscussionInOrgRequest {
	return ApiTeamsGetDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussion
func (a *TeamsApiService) TeamsGetDiscussionInOrgExecute(r ApiTeamsGetDiscussionInOrgRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetDiscussionInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
}

func (r ApiTeamsGetDiscussionLegacyRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsGetDiscussionLegacyExecute(r)
}

/*
TeamsGetDiscussionLegacy Get a discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/reference/teams#get-a-discussion) endpoint.

Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsGetDiscussionLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsGetDiscussionLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiTeamsGetDiscussionLegacyRequest {
	return ApiTeamsGetDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussion
// Deprecated
func (a *TeamsApiService) TeamsGetDiscussionLegacyExecute(r ApiTeamsGetDiscussionLegacyRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetDiscussionLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
}

func (r ApiTeamsGetLegacyRequest) Execute() (*TeamFull, *http.Response, error) {
	return r.ApiService.TeamsGetLegacyExecute(r)
}

/*
TeamsGetLegacy Get a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/reference/teams#get-a-team-by-name) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsGetLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsGetLegacy(ctx context.Context, teamId int32) ApiTeamsGetLegacyRequest {
	return ApiTeamsGetLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return TeamFull
// Deprecated
func (a *TeamsApiService) TeamsGetLegacyExecute(r ApiTeamsGetLegacyRequest) (*TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetMemberLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
}

func (r ApiTeamsGetMemberLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsGetMemberLegacyExecute(r)
}

/*
TeamsGetMemberLegacy Get team member (Legacy)

The "Get team member" endpoint (described below) is deprecated.

We recommend using the [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.

To list members in a team, the team must be visible to the authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsGetMemberLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsGetMemberLegacy(ctx context.Context, teamId int32, username string) ApiTeamsGetMemberLegacyRequest {
	return ApiTeamsGetMemberLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsGetMemberLegacyExecute(r ApiTeamsGetMemberLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetMemberLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/members/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsGetMembershipForUserInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	username string
}

func (r ApiTeamsGetMembershipForUserInOrgRequest) Execute() (*TeamMembership, *http.Response, error) {
	return r.ApiService.TeamsGetMembershipForUserInOrgExecute(r)
}

/*
TeamsGetMembershipForUserInOrg Get team membership for a user

Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.

**Note:**
The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param username The handle for the GitHub user account.
 @return ApiTeamsGetMembershipForUserInOrgRequest
*/
func (a *TeamsApiService) TeamsGetMembershipForUserInOrg(ctx context.Context, org string, teamSlug string, username string) ApiTeamsGetMembershipForUserInOrgRequest {
	return ApiTeamsGetMembershipForUserInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		username: username,
	}
}

// Execute executes the request
//  @return TeamMembership
func (a *TeamsApiService) TeamsGetMembershipForUserInOrgExecute(r ApiTeamsGetMembershipForUserInOrgRequest) (*TeamMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetMembershipForUserInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsGetMembershipForUserLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
}

func (r ApiTeamsGetMembershipForUserLegacyRequest) Execute() (*TeamMembership, *http.Response, error) {
	return r.ApiService.TeamsGetMembershipForUserLegacyExecute(r)
}

/*
TeamsGetMembershipForUserLegacy Get team membership for a user (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.

Team members will include the members of child teams.

To get a user's membership with a team, the team must be visible to the authenticated user.

**Note:**
The response contains the `state` of the membership and the member's `role`.

The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsGetMembershipForUserLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsGetMembershipForUserLegacy(ctx context.Context, teamId int32, username string) ApiTeamsGetMembershipForUserLegacyRequest {
	return ApiTeamsGetMembershipForUserLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
//  @return TeamMembership
// Deprecated
func (a *TeamsApiService) TeamsGetMembershipForUserLegacyExecute(r ApiTeamsGetMembershipForUserLegacyRequest) (*TeamMembership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamMembership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsGetMembershipForUserLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	teamsLinkExternalIdpGroupToTeamForOrgRequest *TeamsLinkExternalIdpGroupToTeamForOrgRequest
}

func (r ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest) TeamsLinkExternalIdpGroupToTeamForOrgRequest(teamsLinkExternalIdpGroupToTeamForOrgRequest TeamsLinkExternalIdpGroupToTeamForOrgRequest) ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest {
	r.teamsLinkExternalIdpGroupToTeamForOrgRequest = &teamsLinkExternalIdpGroupToTeamForOrgRequest
	return r
}

func (r ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest) Execute() (*ExternalGroup, *http.Response, error) {
	return r.ApiService.TeamsLinkExternalIdpGroupToTeamForOrgExecute(r)
}

/*
TeamsLinkExternalIdpGroupToTeamForOrg Update the connection between an external group and a team

Creates a connection between a team and an external group.  Only one external group can be linked to a team.

You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest
*/
func (a *TeamsApiService) TeamsLinkExternalIdpGroupToTeamForOrg(ctx context.Context, org string, teamSlug string) ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest {
	return ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return ExternalGroup
func (a *TeamsApiService) TeamsLinkExternalIdpGroupToTeamForOrgExecute(r ApiTeamsLinkExternalIdpGroupToTeamForOrgRequest) (*ExternalGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsLinkExternalIdpGroupToTeamForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/external-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsLinkExternalIdpGroupToTeamForOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsLinkExternalIdpGroupToTeamForOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsLinkExternalIdpGroupToTeamForOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListRequest) PerPage(perPage int32) ApiTeamsListRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListRequest) Page(page int32) ApiTeamsListRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListRequest) Execute() ([]Team, *http.Response, error) {
	return r.ApiService.TeamsListExecute(r)
}

/*
TeamsList List teams

Lists all teams in an organization that are visible to the authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiTeamsListRequest
*/
func (a *TeamsApiService) TeamsList(ctx context.Context, org string) ApiTeamsListRequest {
	return ApiTeamsListRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []Team
func (a *TeamsApiService) TeamsListExecute(r ApiTeamsListRequest) ([]Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListChildInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListChildInOrgRequest) PerPage(perPage int32) ApiTeamsListChildInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListChildInOrgRequest) Page(page int32) ApiTeamsListChildInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListChildInOrgRequest) Execute() ([]Team, *http.Response, error) {
	return r.ApiService.TeamsListChildInOrgExecute(r)
}

/*
TeamsListChildInOrg List child teams

Lists the child teams of the team specified by `{team_slug}`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListChildInOrgRequest
*/
func (a *TeamsApiService) TeamsListChildInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListChildInOrgRequest {
	return ApiTeamsListChildInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []Team
func (a *TeamsApiService) TeamsListChildInOrgExecute(r ApiTeamsListChildInOrgRequest) ([]Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListChildInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListChildLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListChildLegacyRequest) PerPage(perPage int32) ApiTeamsListChildLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListChildLegacyRequest) Page(page int32) ApiTeamsListChildLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListChildLegacyRequest) Execute() ([]Team, *http.Response, error) {
	return r.ApiService.TeamsListChildLegacyExecute(r)
}

/*
TeamsListChildLegacy List child teams (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/reference/teams#list-child-teams) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListChildLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListChildLegacy(ctx context.Context, teamId int32) ApiTeamsListChildLegacyRequest {
	return ApiTeamsListChildLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []Team
// Deprecated
func (a *TeamsApiService) TeamsListChildLegacyExecute(r ApiTeamsListChildLegacyRequest) ([]Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListChildLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListDiscussionCommentsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	direction *string
	perPage *int32
	page *int32
}

// The direction to sort the results by.
func (r ApiTeamsListDiscussionCommentsInOrgRequest) Direction(direction string) ApiTeamsListDiscussionCommentsInOrgRequest {
	r.direction = &direction
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListDiscussionCommentsInOrgRequest) PerPage(perPage int32) ApiTeamsListDiscussionCommentsInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListDiscussionCommentsInOrgRequest) Page(page int32) ApiTeamsListDiscussionCommentsInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListDiscussionCommentsInOrgRequest) Execute() ([]TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsListDiscussionCommentsInOrgExecute(r)
}

/*
TeamsListDiscussionCommentsInOrg List discussion comments

List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsListDiscussionCommentsInOrgRequest
*/
func (a *TeamsApiService) TeamsListDiscussionCommentsInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiTeamsListDiscussionCommentsInOrgRequest {
	return ApiTeamsListDiscussionCommentsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return []TeamDiscussionComment
func (a *TeamsApiService) TeamsListDiscussionCommentsInOrgExecute(r ApiTeamsListDiscussionCommentsInOrgRequest) ([]TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListDiscussionCommentsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		localVarQueryParams.Add("direction", parameterToString(*r.direction, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListDiscussionCommentsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	direction *string
	perPage *int32
	page *int32
}

// The direction to sort the results by.
func (r ApiTeamsListDiscussionCommentsLegacyRequest) Direction(direction string) ApiTeamsListDiscussionCommentsLegacyRequest {
	r.direction = &direction
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListDiscussionCommentsLegacyRequest) PerPage(perPage int32) ApiTeamsListDiscussionCommentsLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListDiscussionCommentsLegacyRequest) Page(page int32) ApiTeamsListDiscussionCommentsLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListDiscussionCommentsLegacyRequest) Execute() ([]TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsListDiscussionCommentsLegacyExecute(r)
}

/*
TeamsListDiscussionCommentsLegacy List discussion comments (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/reference/teams#list-discussion-comments) endpoint.

List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsListDiscussionCommentsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListDiscussionCommentsLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiTeamsListDiscussionCommentsLegacyRequest {
	return ApiTeamsListDiscussionCommentsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return []TeamDiscussionComment
// Deprecated
func (a *TeamsApiService) TeamsListDiscussionCommentsLegacyExecute(r ApiTeamsListDiscussionCommentsLegacyRequest) ([]TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListDiscussionCommentsLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		localVarQueryParams.Add("direction", parameterToString(*r.direction, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListDiscussionsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	direction *string
	perPage *int32
	page *int32
	pinned *string
}

// The direction to sort the results by.
func (r ApiTeamsListDiscussionsInOrgRequest) Direction(direction string) ApiTeamsListDiscussionsInOrgRequest {
	r.direction = &direction
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListDiscussionsInOrgRequest) PerPage(perPage int32) ApiTeamsListDiscussionsInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListDiscussionsInOrgRequest) Page(page int32) ApiTeamsListDiscussionsInOrgRequest {
	r.page = &page
	return r
}

// Pinned discussions only filter
func (r ApiTeamsListDiscussionsInOrgRequest) Pinned(pinned string) ApiTeamsListDiscussionsInOrgRequest {
	r.pinned = &pinned
	return r
}

func (r ApiTeamsListDiscussionsInOrgRequest) Execute() ([]TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsListDiscussionsInOrgExecute(r)
}

/*
TeamsListDiscussionsInOrg List discussions

List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListDiscussionsInOrgRequest
*/
func (a *TeamsApiService) TeamsListDiscussionsInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListDiscussionsInOrgRequest {
	return ApiTeamsListDiscussionsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []TeamDiscussion
func (a *TeamsApiService) TeamsListDiscussionsInOrgExecute(r ApiTeamsListDiscussionsInOrgRequest) ([]TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListDiscussionsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		localVarQueryParams.Add("direction", parameterToString(*r.direction, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pinned != nil {
		localVarQueryParams.Add("pinned", parameterToString(*r.pinned, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListDiscussionsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	direction *string
	perPage *int32
	page *int32
}

// The direction to sort the results by.
func (r ApiTeamsListDiscussionsLegacyRequest) Direction(direction string) ApiTeamsListDiscussionsLegacyRequest {
	r.direction = &direction
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListDiscussionsLegacyRequest) PerPage(perPage int32) ApiTeamsListDiscussionsLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListDiscussionsLegacyRequest) Page(page int32) ApiTeamsListDiscussionsLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListDiscussionsLegacyRequest) Execute() ([]TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsListDiscussionsLegacyExecute(r)
}

/*
TeamsListDiscussionsLegacy List discussions (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/reference/teams#list-discussions) endpoint.

List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListDiscussionsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListDiscussionsLegacy(ctx context.Context, teamId int32) ApiTeamsListDiscussionsLegacyRequest {
	return ApiTeamsListDiscussionsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []TeamDiscussion
// Deprecated
func (a *TeamsApiService) TeamsListDiscussionsLegacyExecute(r ApiTeamsListDiscussionsLegacyRequest) ([]TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListDiscussionsLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.direction != nil {
		localVarQueryParams.Add("direction", parameterToString(*r.direction, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListExternalIdpGroupsForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	perPage *int32
	page *int32
	displayName *string
}

// The number of results per page (max 100).
func (r ApiTeamsListExternalIdpGroupsForOrgRequest) PerPage(perPage int32) ApiTeamsListExternalIdpGroupsForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page token
func (r ApiTeamsListExternalIdpGroupsForOrgRequest) Page(page int32) ApiTeamsListExternalIdpGroupsForOrgRequest {
	r.page = &page
	return r
}

// Limits the list to groups containing the text in the group name
func (r ApiTeamsListExternalIdpGroupsForOrgRequest) DisplayName(displayName string) ApiTeamsListExternalIdpGroupsForOrgRequest {
	r.displayName = &displayName
	return r
}

func (r ApiTeamsListExternalIdpGroupsForOrgRequest) Execute() (*ExternalGroups, *http.Response, error) {
	return r.ApiService.TeamsListExternalIdpGroupsForOrgExecute(r)
}

/*
TeamsListExternalIdpGroupsForOrg List external groups in an organization

Lists external groups available in an organization. You can query the groups using the `display_name` parameter, only groups with a `group_name` containing the text provided in the `display_name` parameter will be returned.  You can also limit your page results using the `per_page` parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89)."

You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiTeamsListExternalIdpGroupsForOrgRequest
*/
func (a *TeamsApiService) TeamsListExternalIdpGroupsForOrg(ctx context.Context, org string) ApiTeamsListExternalIdpGroupsForOrgRequest {
	return ApiTeamsListExternalIdpGroupsForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return ExternalGroups
func (a *TeamsApiService) TeamsListExternalIdpGroupsForOrgExecute(r ApiTeamsListExternalIdpGroupsForOrgRequest) (*ExternalGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListExternalIdpGroupsForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/external-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.displayName != nil {
		localVarQueryParams.Add("display_name", parameterToString(*r.displayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListForAuthenticatedUserRequest) PerPage(perPage int32) ApiTeamsListForAuthenticatedUserRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListForAuthenticatedUserRequest) Page(page int32) ApiTeamsListForAuthenticatedUserRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListForAuthenticatedUserRequest) Execute() ([]TeamFull, *http.Response, error) {
	return r.ApiService.TeamsListForAuthenticatedUserExecute(r)
}

/*
TeamsListForAuthenticatedUser List teams for the authenticated user

List all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/apps/building-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTeamsListForAuthenticatedUserRequest
*/
func (a *TeamsApiService) TeamsListForAuthenticatedUser(ctx context.Context) ApiTeamsListForAuthenticatedUserRequest {
	return ApiTeamsListForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TeamFull
func (a *TeamsApiService) TeamsListForAuthenticatedUserExecute(r ApiTeamsListForAuthenticatedUserRequest) ([]TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListForAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/teams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListIdpGroupsForLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
}

func (r ApiTeamsListIdpGroupsForLegacyRequest) Execute() (*GroupMapping, *http.Response, error) {
	return r.ApiService.TeamsListIdpGroupsForLegacyExecute(r)
}

/*
TeamsListIdpGroupsForLegacy List IdP groups for a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List IdP groups for a team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

List IdP groups connected to a team on GitHub.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListIdpGroupsForLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListIdpGroupsForLegacy(ctx context.Context, teamId int32) ApiTeamsListIdpGroupsForLegacyRequest {
	return ApiTeamsListIdpGroupsForLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return GroupMapping
// Deprecated
func (a *TeamsApiService) TeamsListIdpGroupsForLegacyExecute(r ApiTeamsListIdpGroupsForLegacyRequest) (*GroupMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListIdpGroupsForLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/team-sync/group-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListIdpGroupsForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	perPage *int32
	page *string
}

// The number of results per page (max 100).
func (r ApiTeamsListIdpGroupsForOrgRequest) PerPage(perPage int32) ApiTeamsListIdpGroupsForOrgRequest {
	r.perPage = &perPage
	return r
}

// Page token
func (r ApiTeamsListIdpGroupsForOrgRequest) Page(page string) ApiTeamsListIdpGroupsForOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListIdpGroupsForOrgRequest) Execute() (*GroupMapping, *http.Response, error) {
	return r.ApiService.TeamsListIdpGroupsForOrgExecute(r)
}

/*
TeamsListIdpGroupsForOrg List IdP groups for an organization

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

List IdP groups available in an organization. You can limit your page results using the `per_page` parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiTeamsListIdpGroupsForOrgRequest
*/
func (a *TeamsApiService) TeamsListIdpGroupsForOrg(ctx context.Context, org string) ApiTeamsListIdpGroupsForOrgRequest {
	return ApiTeamsListIdpGroupsForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return GroupMapping
func (a *TeamsApiService) TeamsListIdpGroupsForOrgExecute(r ApiTeamsListIdpGroupsForOrgRequest) (*GroupMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListIdpGroupsForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/team-sync/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListIdpGroupsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
}

func (r ApiTeamsListIdpGroupsInOrgRequest) Execute() (*GroupMapping, *http.Response, error) {
	return r.ApiService.TeamsListIdpGroupsInOrgExecute(r)
}

/*
TeamsListIdpGroupsInOrg List IdP groups for a team

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

List IdP groups connected to a team on GitHub.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListIdpGroupsInOrgRequest
*/
func (a *TeamsApiService) TeamsListIdpGroupsInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListIdpGroupsInOrgRequest {
	return ApiTeamsListIdpGroupsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return GroupMapping
func (a *TeamsApiService) TeamsListIdpGroupsInOrgExecute(r ApiTeamsListIdpGroupsInOrgRequest) (*GroupMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListIdpGroupsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
}

func (r ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest) Execute() (*ExternalGroups, *http.Response, error) {
	return r.ApiService.TeamsListLinkedExternalIdpGroupsToTeamForOrgExecute(r)
}

/*
TeamsListLinkedExternalIdpGroupsToTeamForOrg List a connection between an external group and a team

Lists a connection between a team and an external group.

You can manage team membership with your identity provider using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)" in the GitHub Help documentation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest
*/
func (a *TeamsApiService) TeamsListLinkedExternalIdpGroupsToTeamForOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest {
	return ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return ExternalGroups
func (a *TeamsApiService) TeamsListLinkedExternalIdpGroupsToTeamForOrgExecute(r ApiTeamsListLinkedExternalIdpGroupsToTeamForOrgRequest) (*ExternalGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListLinkedExternalIdpGroupsToTeamForOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/external-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListMembersInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	role *string
	perPage *int32
	page *int32
}

// Filters members returned by their role in the team.
func (r ApiTeamsListMembersInOrgRequest) Role(role string) ApiTeamsListMembersInOrgRequest {
	r.role = &role
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListMembersInOrgRequest) PerPage(perPage int32) ApiTeamsListMembersInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListMembersInOrgRequest) Page(page int32) ApiTeamsListMembersInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListMembersInOrgRequest) Execute() ([]SimpleUser, *http.Response, error) {
	return r.ApiService.TeamsListMembersInOrgExecute(r)
}

/*
TeamsListMembersInOrg List team members

Team members will include the members of child teams.

To list members in a team, the team must be visible to the authenticated user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListMembersInOrgRequest
*/
func (a *TeamsApiService) TeamsListMembersInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListMembersInOrgRequest {
	return ApiTeamsListMembersInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []SimpleUser
func (a *TeamsApiService) TeamsListMembersInOrgExecute(r ApiTeamsListMembersInOrgRequest) ([]SimpleUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimpleUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListMembersInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListMembersLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	role *string
	perPage *int32
	page *int32
}

// Filters members returned by their role in the team.
func (r ApiTeamsListMembersLegacyRequest) Role(role string) ApiTeamsListMembersLegacyRequest {
	r.role = &role
	return r
}

// The number of results per page (max 100).
func (r ApiTeamsListMembersLegacyRequest) PerPage(perPage int32) ApiTeamsListMembersLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListMembersLegacyRequest) Page(page int32) ApiTeamsListMembersLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListMembersLegacyRequest) Execute() ([]SimpleUser, *http.Response, error) {
	return r.ApiService.TeamsListMembersLegacyExecute(r)
}

/*
TeamsListMembersLegacy List team members (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/reference/teams#list-team-members) endpoint.

Team members will include the members of child teams.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListMembersLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListMembersLegacy(ctx context.Context, teamId int32) ApiTeamsListMembersLegacyRequest {
	return ApiTeamsListMembersLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []SimpleUser
// Deprecated
func (a *TeamsApiService) TeamsListMembersLegacyExecute(r ApiTeamsListMembersLegacyRequest) ([]SimpleUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SimpleUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListMembersLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListPendingInvitationsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListPendingInvitationsInOrgRequest) PerPage(perPage int32) ApiTeamsListPendingInvitationsInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListPendingInvitationsInOrgRequest) Page(page int32) ApiTeamsListPendingInvitationsInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListPendingInvitationsInOrgRequest) Execute() ([]OrganizationInvitation, *http.Response, error) {
	return r.ApiService.TeamsListPendingInvitationsInOrgExecute(r)
}

/*
TeamsListPendingInvitationsInOrg List pending team invitations

The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/invitations`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListPendingInvitationsInOrgRequest
*/
func (a *TeamsApiService) TeamsListPendingInvitationsInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListPendingInvitationsInOrgRequest {
	return ApiTeamsListPendingInvitationsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []OrganizationInvitation
func (a *TeamsApiService) TeamsListPendingInvitationsInOrgExecute(r ApiTeamsListPendingInvitationsInOrgRequest) ([]OrganizationInvitation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrganizationInvitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListPendingInvitationsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListPendingInvitationsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListPendingInvitationsLegacyRequest) PerPage(perPage int32) ApiTeamsListPendingInvitationsLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListPendingInvitationsLegacyRequest) Page(page int32) ApiTeamsListPendingInvitationsLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListPendingInvitationsLegacyRequest) Execute() ([]OrganizationInvitation, *http.Response, error) {
	return r.ApiService.TeamsListPendingInvitationsLegacyExecute(r)
}

/*
TeamsListPendingInvitationsLegacy List pending team invitations (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.

The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListPendingInvitationsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListPendingInvitationsLegacy(ctx context.Context, teamId int32) ApiTeamsListPendingInvitationsLegacyRequest {
	return ApiTeamsListPendingInvitationsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []OrganizationInvitation
// Deprecated
func (a *TeamsApiService) TeamsListPendingInvitationsLegacyExecute(r ApiTeamsListPendingInvitationsLegacyRequest) ([]OrganizationInvitation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrganizationInvitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListPendingInvitationsLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/invitations"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListProjectsInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListProjectsInOrgRequest) PerPage(perPage int32) ApiTeamsListProjectsInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListProjectsInOrgRequest) Page(page int32) ApiTeamsListProjectsInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListProjectsInOrgRequest) Execute() ([]TeamProject, *http.Response, error) {
	return r.ApiService.TeamsListProjectsInOrgExecute(r)
}

/*
TeamsListProjectsInOrg List team projects

Lists the organization projects for a team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListProjectsInOrgRequest
*/
func (a *TeamsApiService) TeamsListProjectsInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListProjectsInOrgRequest {
	return ApiTeamsListProjectsInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []TeamProject
func (a *TeamsApiService) TeamsListProjectsInOrgExecute(r ApiTeamsListProjectsInOrgRequest) ([]TeamProject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListProjectsInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListProjectsLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListProjectsLegacyRequest) PerPage(perPage int32) ApiTeamsListProjectsLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListProjectsLegacyRequest) Page(page int32) ApiTeamsListProjectsLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListProjectsLegacyRequest) Execute() ([]TeamProject, *http.Response, error) {
	return r.ApiService.TeamsListProjectsLegacyExecute(r)
}

/*
TeamsListProjectsLegacy List team projects (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/rest/reference/teams#list-team-projects) endpoint.

Lists the organization projects for a team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListProjectsLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListProjectsLegacy(ctx context.Context, teamId int32) ApiTeamsListProjectsLegacyRequest {
	return ApiTeamsListProjectsLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []TeamProject
// Deprecated
func (a *TeamsApiService) TeamsListProjectsLegacyExecute(r ApiTeamsListProjectsLegacyRequest) ([]TeamProject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TeamProject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListProjectsLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListReposInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListReposInOrgRequest) PerPage(perPage int32) ApiTeamsListReposInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListReposInOrgRequest) Page(page int32) ApiTeamsListReposInOrgRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListReposInOrgRequest) Execute() ([]MinimalRepository, *http.Response, error) {
	return r.ApiService.TeamsListReposInOrgExecute(r)
}

/*
TeamsListReposInOrg List team repositories

Lists a team's repositories visible to the authenticated user.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsListReposInOrgRequest
*/
func (a *TeamsApiService) TeamsListReposInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsListReposInOrgRequest {
	return ApiTeamsListReposInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return []MinimalRepository
func (a *TeamsApiService) TeamsListReposInOrgExecute(r ApiTeamsListReposInOrgRequest) ([]MinimalRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MinimalRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListReposInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/repos"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsListReposLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiTeamsListReposLegacyRequest) PerPage(perPage int32) ApiTeamsListReposLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiTeamsListReposLegacyRequest) Page(page int32) ApiTeamsListReposLegacyRequest {
	r.page = &page
	return r
}

func (r ApiTeamsListReposLegacyRequest) Execute() ([]MinimalRepository, *http.Response, error) {
	return r.ApiService.TeamsListReposLegacyExecute(r)
}

/*
TeamsListReposLegacy List team repositories (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/reference/teams#list-team-repositories) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsListReposLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsListReposLegacy(ctx context.Context, teamId int32) ApiTeamsListReposLegacyRequest {
	return ApiTeamsListReposLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return []MinimalRepository
// Deprecated
func (a *TeamsApiService) TeamsListReposLegacyExecute(r ApiTeamsListReposLegacyRequest) ([]MinimalRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MinimalRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsListReposLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/repos"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsRemoveMemberLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
}

func (r ApiTeamsRemoveMemberLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveMemberLegacyExecute(r)
}

/*
TeamsRemoveMemberLegacy Remove team member (Legacy)

The "Remove team member" endpoint (described below) is deprecated.

We recommend using the [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsRemoveMemberLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsRemoveMemberLegacy(ctx context.Context, teamId int32, username string) ApiTeamsRemoveMemberLegacyRequest {
	return ApiTeamsRemoveMemberLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsRemoveMemberLegacyExecute(r ApiTeamsRemoveMemberLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveMemberLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/members/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveMembershipForUserInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	username string
}

func (r ApiTeamsRemoveMembershipForUserInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveMembershipForUserInOrgExecute(r)
}

/*
TeamsRemoveMembershipForUserInOrg Remove team membership for a user

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param username The handle for the GitHub user account.
 @return ApiTeamsRemoveMembershipForUserInOrgRequest
*/
func (a *TeamsApiService) TeamsRemoveMembershipForUserInOrg(ctx context.Context, org string, teamSlug string, username string) ApiTeamsRemoveMembershipForUserInOrgRequest {
	return ApiTeamsRemoveMembershipForUserInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		username: username,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsRemoveMembershipForUserInOrgExecute(r ApiTeamsRemoveMembershipForUserInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveMembershipForUserInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveMembershipForUserLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	username string
}

func (r ApiTeamsRemoveMembershipForUserLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveMembershipForUserLegacyExecute(r)
}

/*
TeamsRemoveMembershipForUserLegacy Remove team membership for a user (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.

Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.

**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param username The handle for the GitHub user account.
 @return ApiTeamsRemoveMembershipForUserLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsRemoveMembershipForUserLegacy(ctx context.Context, teamId int32, username string) ApiTeamsRemoveMembershipForUserLegacyRequest {
	return ApiTeamsRemoveMembershipForUserLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		username: username,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsRemoveMembershipForUserLegacyExecute(r ApiTeamsRemoveMembershipForUserLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveMembershipForUserLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/memberships/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveProjectInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	projectId int32
}

func (r ApiTeamsRemoveProjectInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveProjectInOrgExecute(r)
}

/*
TeamsRemoveProjectInOrg Remove a project from a team

Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. This endpoint removes the project from the team, but does not delete the project.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/projects/{project_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param projectId The unique identifier of the project.
 @return ApiTeamsRemoveProjectInOrgRequest
*/
func (a *TeamsApiService) TeamsRemoveProjectInOrg(ctx context.Context, org string, teamSlug string, projectId int32) ApiTeamsRemoveProjectInOrgRequest {
	return ApiTeamsRemoveProjectInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsRemoveProjectInOrgExecute(r ApiTeamsRemoveProjectInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveProjectInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveProjectLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	projectId int32
}

func (r ApiTeamsRemoveProjectLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveProjectLegacyExecute(r)
}

/*
TeamsRemoveProjectLegacy Remove a project from a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.

Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param projectId The unique identifier of the project.
 @return ApiTeamsRemoveProjectLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsRemoveProjectLegacy(ctx context.Context, teamId int32, projectId int32) ApiTeamsRemoveProjectLegacyRequest {
	return ApiTeamsRemoveProjectLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		projectId: projectId,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsRemoveProjectLegacyExecute(r ApiTeamsRemoveProjectLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveProjectLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/projects/{project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveRepoInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	owner string
	repo string
}

func (r ApiTeamsRemoveRepoInOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveRepoInOrgExecute(r)
}

/*
TeamsRemoveRepoInOrg Remove a repository from a team

If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsRemoveRepoInOrgRequest
*/
func (a *TeamsApiService) TeamsRemoveRepoInOrg(ctx context.Context, org string, teamSlug string, owner string, repo string) ApiTeamsRemoveRepoInOrgRequest {
	return ApiTeamsRemoveRepoInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsRemoveRepoInOrgExecute(r ApiTeamsRemoveRepoInOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveRepoInOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsRemoveRepoLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	owner string
	repo string
}

func (r ApiTeamsRemoveRepoLegacyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsRemoveRepoLegacyExecute(r)
}

/*
TeamsRemoveRepoLegacy Remove a repository from a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.

If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiTeamsRemoveRepoLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsRemoveRepoLegacy(ctx context.Context, teamId int32, owner string, repo string) ApiTeamsRemoveRepoLegacyRequest {
	return ApiTeamsRemoveRepoLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
// Deprecated
func (a *TeamsApiService) TeamsRemoveRepoLegacyExecute(r ApiTeamsRemoveRepoLegacyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsRemoveRepoLegacy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/repos/{owner}/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
}

func (r ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.TeamsUnlinkExternalIdpGroupFromTeamForOrgExecute(r)
}

/*
TeamsUnlinkExternalIdpGroupFromTeamForOrg Remove the connection between an external group and a team

Deletes a connection between a team and an external group.

You can manage team membership with your IdP using Enterprise Managed Users for GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest
*/
func (a *TeamsApiService) TeamsUnlinkExternalIdpGroupFromTeamForOrg(ctx context.Context, org string, teamSlug string) ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest {
	return ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
func (a *TeamsApiService) TeamsUnlinkExternalIdpGroupFromTeamForOrgExecute(r ApiTeamsUnlinkExternalIdpGroupFromTeamForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUnlinkExternalIdpGroupFromTeamForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/external-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTeamsUpdateDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
	teamsCreateDiscussionCommentInOrgRequest *TeamsCreateDiscussionCommentInOrgRequest
}

func (r ApiTeamsUpdateDiscussionCommentInOrgRequest) TeamsCreateDiscussionCommentInOrgRequest(teamsCreateDiscussionCommentInOrgRequest TeamsCreateDiscussionCommentInOrgRequest) ApiTeamsUpdateDiscussionCommentInOrgRequest {
	r.teamsCreateDiscussionCommentInOrgRequest = &teamsCreateDiscussionCommentInOrgRequest
	return r
}

func (r ApiTeamsUpdateDiscussionCommentInOrgRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsUpdateDiscussionCommentInOrgExecute(r)
}

/*
TeamsUpdateDiscussionCommentInOrg Update a discussion comment

Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsUpdateDiscussionCommentInOrgRequest
*/
func (a *TeamsApiService) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32) ApiTeamsUpdateDiscussionCommentInOrgRequest {
	return ApiTeamsUpdateDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
func (a *TeamsApiService) TeamsUpdateDiscussionCommentInOrgExecute(r ApiTeamsUpdateDiscussionCommentInOrgRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateDiscussionCommentInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsUpdateDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	commentNumber int32
	teamsCreateDiscussionCommentInOrgRequest *TeamsCreateDiscussionCommentInOrgRequest
}

func (r ApiTeamsUpdateDiscussionCommentLegacyRequest) TeamsCreateDiscussionCommentInOrgRequest(teamsCreateDiscussionCommentInOrgRequest TeamsCreateDiscussionCommentInOrgRequest) ApiTeamsUpdateDiscussionCommentLegacyRequest {
	r.teamsCreateDiscussionCommentInOrgRequest = &teamsCreateDiscussionCommentInOrgRequest
	return r
}

func (r ApiTeamsUpdateDiscussionCommentLegacyRequest) Execute() (*TeamDiscussionComment, *http.Response, error) {
	return r.ApiService.TeamsUpdateDiscussionCommentLegacyExecute(r)
}

/*
TeamsUpdateDiscussionCommentLegacy Update a discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.

Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiTeamsUpdateDiscussionCommentLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32, commentNumber int32) ApiTeamsUpdateDiscussionCommentLegacyRequest {
	return ApiTeamsUpdateDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussionComment
// Deprecated
func (a *TeamsApiService) TeamsUpdateDiscussionCommentLegacyExecute(r ApiTeamsUpdateDiscussionCommentLegacyRequest) (*TeamDiscussionComment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussionComment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateDiscussionCommentLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsCreateDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("teamsCreateDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsCreateDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsUpdateDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	discussionNumber int32
	teamsUpdateDiscussionInOrgRequest *TeamsUpdateDiscussionInOrgRequest
}

func (r ApiTeamsUpdateDiscussionInOrgRequest) TeamsUpdateDiscussionInOrgRequest(teamsUpdateDiscussionInOrgRequest TeamsUpdateDiscussionInOrgRequest) ApiTeamsUpdateDiscussionInOrgRequest {
	r.teamsUpdateDiscussionInOrgRequest = &teamsUpdateDiscussionInOrgRequest
	return r
}

func (r ApiTeamsUpdateDiscussionInOrgRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsUpdateDiscussionInOrgExecute(r)
}

/*
TeamsUpdateDiscussionInOrg Update a discussion

Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsUpdateDiscussionInOrgRequest
*/
func (a *TeamsApiService) TeamsUpdateDiscussionInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiTeamsUpdateDiscussionInOrgRequest {
	return ApiTeamsUpdateDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussion
func (a *TeamsApiService) TeamsUpdateDiscussionInOrgExecute(r ApiTeamsUpdateDiscussionInOrgRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateDiscussionInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsUpdateDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsUpdateDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	discussionNumber int32
	teamsUpdateDiscussionInOrgRequest *TeamsUpdateDiscussionInOrgRequest
}

func (r ApiTeamsUpdateDiscussionLegacyRequest) TeamsUpdateDiscussionInOrgRequest(teamsUpdateDiscussionInOrgRequest TeamsUpdateDiscussionInOrgRequest) ApiTeamsUpdateDiscussionLegacyRequest {
	r.teamsUpdateDiscussionInOrgRequest = &teamsUpdateDiscussionInOrgRequest
	return r
}

func (r ApiTeamsUpdateDiscussionLegacyRequest) Execute() (*TeamDiscussion, *http.Response, error) {
	return r.ApiService.TeamsUpdateDiscussionLegacyExecute(r)
}

/*
TeamsUpdateDiscussionLegacy Update a discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/reference/teams#update-a-discussion) endpoint.

Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiTeamsUpdateDiscussionLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsUpdateDiscussionLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiTeamsUpdateDiscussionLegacyRequest {
	return ApiTeamsUpdateDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return TeamDiscussion
// Deprecated
func (a *TeamsApiService) TeamsUpdateDiscussionLegacyExecute(r ApiTeamsUpdateDiscussionLegacyRequest) (*TeamDiscussion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamDiscussion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateDiscussionLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsUpdateDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsUpdateInOrgRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	org string
	teamSlug string
	teamsUpdateInOrgRequest *TeamsUpdateInOrgRequest
}

func (r ApiTeamsUpdateInOrgRequest) TeamsUpdateInOrgRequest(teamsUpdateInOrgRequest TeamsUpdateInOrgRequest) ApiTeamsUpdateInOrgRequest {
	r.teamsUpdateInOrgRequest = &teamsUpdateInOrgRequest
	return r
}

func (r ApiTeamsUpdateInOrgRequest) Execute() (*TeamFull, *http.Response, error) {
	return r.ApiService.TeamsUpdateInOrgExecute(r)
}

/*
TeamsUpdateInOrg Update a team

To edit a team, the authenticated user must either be an organization owner or a team maintainer.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @return ApiTeamsUpdateInOrgRequest
*/
func (a *TeamsApiService) TeamsUpdateInOrg(ctx context.Context, org string, teamSlug string) ApiTeamsUpdateInOrgRequest {
	return ApiTeamsUpdateInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
	}
}

// Execute executes the request
//  @return TeamFull
func (a *TeamsApiService) TeamsUpdateInOrgExecute(r ApiTeamsUpdateInOrgRequest) (*TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsUpdateInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTeamsUpdateLegacyRequest struct {
	ctx context.Context
	ApiService *TeamsApiService
	teamId int32
	teamsUpdateLegacyRequest *TeamsUpdateLegacyRequest
}

func (r ApiTeamsUpdateLegacyRequest) TeamsUpdateLegacyRequest(teamsUpdateLegacyRequest TeamsUpdateLegacyRequest) ApiTeamsUpdateLegacyRequest {
	r.teamsUpdateLegacyRequest = &teamsUpdateLegacyRequest
	return r
}

func (r ApiTeamsUpdateLegacyRequest) Execute() (*TeamFull, *http.Response, error) {
	return r.ApiService.TeamsUpdateLegacyExecute(r)
}

/*
TeamsUpdateLegacy Update a team (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/reference/teams#update-a-team) endpoint.

To edit a team, the authenticated user must either be an organization owner or a team maintainer.

**Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @return ApiTeamsUpdateLegacyRequest

Deprecated
*/
func (a *TeamsApiService) TeamsUpdateLegacy(ctx context.Context, teamId int32) ApiTeamsUpdateLegacyRequest {
	return ApiTeamsUpdateLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
	}
}

// Execute executes the request
//  @return TeamFull
// Deprecated
func (a *TeamsApiService) TeamsUpdateLegacyExecute(r ApiTeamsUpdateLegacyRequest) (*TeamFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TeamFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TeamsApiService.TeamsUpdateLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsUpdateLegacyRequest == nil {
		return localVarReturnValue, nil, reportError("teamsUpdateLegacyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsUpdateLegacyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
