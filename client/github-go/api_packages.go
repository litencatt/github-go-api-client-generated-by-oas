/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PackagesApiService PackagesApi service
type PackagesApiService service

type ApiPackagesDeletePackageForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
}

func (r ApiPackagesDeletePackageForAuthenticatedUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageForAuthenticatedUserExecute(r)
}

/*
PackagesDeletePackageForAuthenticatedUser Delete a package for the authenticated user

Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @return ApiPackagesDeletePackageForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesDeletePackageForAuthenticatedUser(ctx context.Context, packageType string, packageName string) ApiPackagesDeletePackageForAuthenticatedUserRequest {
	return ApiPackagesDeletePackageForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageForAuthenticatedUserExecute(r ApiPackagesDeletePackageForAuthenticatedUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageForAuthenticatedUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesDeletePackageForOrgRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
}

func (r ApiPackagesDeletePackageForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageForOrgExecute(r)
}

/*
PackagesDeletePackageForOrg Delete a package for an organization

Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @return ApiPackagesDeletePackageForOrgRequest
*/
func (a *PackagesApiService) PackagesDeletePackageForOrg(ctx context.Context, packageType string, packageName string, org string) ApiPackagesDeletePackageForOrgRequest {
	return ApiPackagesDeletePackageForOrgRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageForOrgExecute(r ApiPackagesDeletePackageForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesDeletePackageForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
}

func (r ApiPackagesDeletePackageForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageForUserExecute(r)
}

/*
PackagesDeletePackageForUser Delete a package for a user

Deletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @return ApiPackagesDeletePackageForUserRequest
*/
func (a *PackagesApiService) PackagesDeletePackageForUser(ctx context.Context, packageType string, packageName string, username string) ApiPackagesDeletePackageForUserRequest {
	return ApiPackagesDeletePackageForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageForUserExecute(r ApiPackagesDeletePackageForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesDeletePackageVersionForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	packageVersionId int32
}

func (r ApiPackagesDeletePackageVersionForAuthenticatedUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageVersionForAuthenticatedUserExecute(r)
}

/*
PackagesDeletePackageVersionForAuthenticatedUser Delete a package version for the authenticated user

Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesDeletePackageVersionForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, packageType string, packageName string, packageVersionId int32) ApiPackagesDeletePackageVersionForAuthenticatedUserRequest {
	return ApiPackagesDeletePackageVersionForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageVersionForAuthenticatedUserExecute(r ApiPackagesDeletePackageVersionForAuthenticatedUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageVersionForAuthenticatedUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesDeletePackageVersionForOrgRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
	packageVersionId int32
}

func (r ApiPackagesDeletePackageVersionForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageVersionForOrgExecute(r)
}

/*
PackagesDeletePackageVersionForOrg Delete package version for an organization

Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesDeletePackageVersionForOrgRequest
*/
func (a *PackagesApiService) PackagesDeletePackageVersionForOrg(ctx context.Context, packageType string, packageName string, org string, packageVersionId int32) ApiPackagesDeletePackageVersionForOrgRequest {
	return ApiPackagesDeletePackageVersionForOrgRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageVersionForOrgExecute(r ApiPackagesDeletePackageVersionForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageVersionForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesDeletePackageVersionForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
	packageVersionId int32
}

func (r ApiPackagesDeletePackageVersionForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesDeletePackageVersionForUserExecute(r)
}

/*
PackagesDeletePackageVersionForUser Delete package version for a user

Deletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container you want to delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesDeletePackageVersionForUserRequest
*/
func (a *PackagesApiService) PackagesDeletePackageVersionForUser(ctx context.Context, packageType string, packageName string, username string, packageVersionId int32) ApiPackagesDeletePackageVersionForUserRequest {
	return ApiPackagesDeletePackageVersionForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesDeletePackageVersionForUserExecute(r ApiPackagesDeletePackageVersionForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesDeletePackageVersionForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	page *int32
	perPage *int32
	state *string
}

// Page number of the results to fetch.
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest) Page(page int32) ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest {
	r.page = &page
	return r
}

// The number of results per page (max 100).
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest) PerPage(perPage int32) ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest {
	r.perPage = &perPage
	return r
}

// The state of the package, either active or deleted.
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest) State(state string) ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest {
	r.state = &state
	return r
}

func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest) Execute() ([]PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserExecute(r)
}

/*
PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser Get all package versions for a package owned by the authenticated user

Returns all package versions for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @return ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, packageType string, packageName string) ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest {
	return ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
	}
}

// Execute executes the request
//  @return []PackageVersion
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserExecute(r ApiPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest) ([]PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
	page *int32
	perPage *int32
	state *string
}

// Page number of the results to fetch.
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest) Page(page int32) ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest {
	r.page = &page
	return r
}

// The number of results per page (max 100).
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest) PerPage(perPage int32) ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest {
	r.perPage = &perPage
	return r
}

// The state of the package, either active or deleted.
func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest) State(state string) ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest {
	r.state = &state
	return r
}

func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest) Execute() ([]PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetAllPackageVersionsForPackageOwnedByOrgExecute(r)
}

/*
PackagesGetAllPackageVersionsForPackageOwnedByOrg Get all package versions for a package owned by an organization

Returns all package versions for a package owned by an organization.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @return ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest
*/
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, packageType string, packageName string, org string) ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest {
	return ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
	}
}

// Execute executes the request
//  @return []PackageVersion
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByOrgExecute(r ApiPackagesGetAllPackageVersionsForPackageOwnedByOrgRequest) ([]PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetAllPackageVersionsForPackageOwnedByOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
}

func (r ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest) Execute() ([]PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetAllPackageVersionsForPackageOwnedByUserExecute(r)
}

/*
PackagesGetAllPackageVersionsForPackageOwnedByUser Get all package versions for a package owned by a user

Returns all package versions for a public package owned by a specified user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @return ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest
*/
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, packageType string, packageName string, username string) ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest {
	return ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
	}
}

// Execute executes the request
//  @return []PackageVersion
func (a *PackagesApiService) PackagesGetAllPackageVersionsForPackageOwnedByUserExecute(r ApiPackagesGetAllPackageVersionsForPackageOwnedByUserRequest) ([]PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetAllPackageVersionsForPackageOwnedByUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
}

func (r ApiPackagesGetPackageForAuthenticatedUserRequest) Execute() (*ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesGetPackageForAuthenticatedUserExecute(r)
}

/*
PackagesGetPackageForAuthenticatedUser Get a package for the authenticated user

Gets a specific package for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @return ApiPackagesGetPackageForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesGetPackageForAuthenticatedUser(ctx context.Context, packageType string, packageName string) ApiPackagesGetPackageForAuthenticatedUserRequest {
	return ApiPackagesGetPackageForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
	}
}

// Execute executes the request
//  @return ModelPackage
func (a *PackagesApiService) PackagesGetPackageForAuthenticatedUserExecute(r ApiPackagesGetPackageForAuthenticatedUserRequest) (*ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageForAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageForOrganizationRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
}

func (r ApiPackagesGetPackageForOrganizationRequest) Execute() (*ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesGetPackageForOrganizationExecute(r)
}

/*
PackagesGetPackageForOrganization Get a package for an organization

Gets a specific package in an organization.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @return ApiPackagesGetPackageForOrganizationRequest
*/
func (a *PackagesApiService) PackagesGetPackageForOrganization(ctx context.Context, packageType string, packageName string, org string) ApiPackagesGetPackageForOrganizationRequest {
	return ApiPackagesGetPackageForOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
	}
}

// Execute executes the request
//  @return ModelPackage
func (a *PackagesApiService) PackagesGetPackageForOrganizationExecute(r ApiPackagesGetPackageForOrganizationRequest) (*ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageForOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
}

func (r ApiPackagesGetPackageForUserRequest) Execute() (*ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesGetPackageForUserExecute(r)
}

/*
PackagesGetPackageForUser Get a package for a user

Gets a specific package metadata for a public package owned by a user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @return ApiPackagesGetPackageForUserRequest
*/
func (a *PackagesApiService) PackagesGetPackageForUser(ctx context.Context, packageType string, packageName string, username string) ApiPackagesGetPackageForUserRequest {
	return ApiPackagesGetPackageForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
	}
}

// Execute executes the request
//  @return ModelPackage
func (a *PackagesApiService) PackagesGetPackageForUserExecute(r ApiPackagesGetPackageForUserRequest) (*ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageVersionForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	packageVersionId int32
}

func (r ApiPackagesGetPackageVersionForAuthenticatedUserRequest) Execute() (*PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetPackageVersionForAuthenticatedUserExecute(r)
}

/*
PackagesGetPackageVersionForAuthenticatedUser Get a package version for the authenticated user

Gets a specific package version for a package owned by the authenticated user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesGetPackageVersionForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, packageType string, packageName string, packageVersionId int32) ApiPackagesGetPackageVersionForAuthenticatedUserRequest {
	return ApiPackagesGetPackageVersionForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
//  @return PackageVersion
func (a *PackagesApiService) PackagesGetPackageVersionForAuthenticatedUserExecute(r ApiPackagesGetPackageVersionForAuthenticatedUserRequest) (*PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageVersionForAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageVersionForOrganizationRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
	packageVersionId int32
}

func (r ApiPackagesGetPackageVersionForOrganizationRequest) Execute() (*PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetPackageVersionForOrganizationExecute(r)
}

/*
PackagesGetPackageVersionForOrganization Get a package version for an organization

Gets a specific package version in an organization.

You must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesGetPackageVersionForOrganizationRequest
*/
func (a *PackagesApiService) PackagesGetPackageVersionForOrganization(ctx context.Context, packageType string, packageName string, org string, packageVersionId int32) ApiPackagesGetPackageVersionForOrganizationRequest {
	return ApiPackagesGetPackageVersionForOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
//  @return PackageVersion
func (a *PackagesApiService) PackagesGetPackageVersionForOrganizationExecute(r ApiPackagesGetPackageVersionForOrganizationRequest) (*PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageVersionForOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesGetPackageVersionForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	packageVersionId int32
	username string
}

func (r ApiPackagesGetPackageVersionForUserRequest) Execute() (*PackageVersion, *http.Response, error) {
	return r.ApiService.PackagesGetPackageVersionForUserExecute(r)
}

/*
PackagesGetPackageVersionForUser Get a package version for a user

Gets a specific package version for a public package owned by a specified user.

At this time, to use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param packageVersionId Unique identifier of the package version.
 @param username The handle for the GitHub user account.
 @return ApiPackagesGetPackageVersionForUserRequest
*/
func (a *PackagesApiService) PackagesGetPackageVersionForUser(ctx context.Context, packageType string, packageName string, packageVersionId int32, username string) ApiPackagesGetPackageVersionForUserRequest {
	return ApiPackagesGetPackageVersionForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		packageVersionId: packageVersionId,
		username: username,
	}
}

// Execute executes the request
//  @return PackageVersion
func (a *PackagesApiService) PackagesGetPackageVersionForUserExecute(r ApiPackagesGetPackageVersionForUserRequest) (*PackageVersion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesGetPackageVersionForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesListPackagesForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType *string
	visibility *string
}

// The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
func (r ApiPackagesListPackagesForAuthenticatedUserRequest) PackageType(packageType string) ApiPackagesListPackagesForAuthenticatedUserRequest {
	r.packageType = &packageType
	return r
}

// The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
func (r ApiPackagesListPackagesForAuthenticatedUserRequest) Visibility(visibility string) ApiPackagesListPackagesForAuthenticatedUserRequest {
	r.visibility = &visibility
	return r
}

func (r ApiPackagesListPackagesForAuthenticatedUserRequest) Execute() ([]ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesListPackagesForAuthenticatedUserExecute(r)
}

/*
PackagesListPackagesForAuthenticatedUser List packages for the authenticated user's namespace

Lists packages owned by the authenticated user within the user's namespace.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPackagesListPackagesForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesListPackagesForAuthenticatedUser(ctx context.Context) ApiPackagesListPackagesForAuthenticatedUserRequest {
	return ApiPackagesListPackagesForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ModelPackage
func (a *PackagesApiService) PackagesListPackagesForAuthenticatedUserExecute(r ApiPackagesListPackagesForAuthenticatedUserRequest) ([]ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesListPackagesForAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageType == nil {
		return localVarReturnValue, nil, reportError("packageType is required and must be specified")
	}

	localVarQueryParams.Add("package_type", parameterToString(*r.packageType, ""))
	if r.visibility != nil {
		localVarQueryParams.Add("visibility", parameterToString(*r.visibility, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesListPackagesForOrganizationRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType *string
	org string
	visibility *string
}

// The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
func (r ApiPackagesListPackagesForOrganizationRequest) PackageType(packageType string) ApiPackagesListPackagesForOrganizationRequest {
	r.packageType = &packageType
	return r
}

// The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
func (r ApiPackagesListPackagesForOrganizationRequest) Visibility(visibility string) ApiPackagesListPackagesForOrganizationRequest {
	r.visibility = &visibility
	return r
}

func (r ApiPackagesListPackagesForOrganizationRequest) Execute() ([]ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesListPackagesForOrganizationExecute(r)
}

/*
PackagesListPackagesForOrganization List packages for an organization

Lists all packages in an organization readable by the user.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiPackagesListPackagesForOrganizationRequest
*/
func (a *PackagesApiService) PackagesListPackagesForOrganization(ctx context.Context, org string) ApiPackagesListPackagesForOrganizationRequest {
	return ApiPackagesListPackagesForOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []ModelPackage
func (a *PackagesApiService) PackagesListPackagesForOrganizationExecute(r ApiPackagesListPackagesForOrganizationRequest) ([]ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesListPackagesForOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageType == nil {
		return localVarReturnValue, nil, reportError("packageType is required and must be specified")
	}

	localVarQueryParams.Add("package_type", parameterToString(*r.packageType, ""))
	if r.visibility != nil {
		localVarQueryParams.Add("visibility", parameterToString(*r.visibility, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesListPackagesForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType *string
	username string
	visibility *string
}

// The type of supported package. Packages in GitHub&#39;s Gradle registry have the type &#x60;maven&#x60;. Docker images pushed to GitHub&#39;s Container registry (&#x60;ghcr.io&#x60;) have the type &#x60;container&#x60;. You can use the type &#x60;docker&#x60; to find images that were pushed to GitHub&#39;s Docker registry (&#x60;docker.pkg.github.com&#x60;), even if these have now been migrated to the Container registry.
func (r ApiPackagesListPackagesForUserRequest) PackageType(packageType string) ApiPackagesListPackagesForUserRequest {
	r.packageType = &packageType
	return r
}

// The selected visibility of the packages. Only &#x60;container&#x60; package_types currently support &#x60;internal&#x60; visibility properly. For other ecosystems &#x60;internal&#x60; is synonymous with &#x60;private&#x60;. This parameter is optional and only filters an existing result set.
func (r ApiPackagesListPackagesForUserRequest) Visibility(visibility string) ApiPackagesListPackagesForUserRequest {
	r.visibility = &visibility
	return r
}

func (r ApiPackagesListPackagesForUserRequest) Execute() ([]ModelPackage, *http.Response, error) {
	return r.ApiService.PackagesListPackagesForUserExecute(r)
}

/*
PackagesListPackagesForUser List packages for a user

Lists all packages in a user's namespace for which the requesting user has access.

To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The handle for the GitHub user account.
 @return ApiPackagesListPackagesForUserRequest
*/
func (a *PackagesApiService) PackagesListPackagesForUser(ctx context.Context, username string) ApiPackagesListPackagesForUserRequest {
	return ApiPackagesListPackagesForUserRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return []ModelPackage
func (a *PackagesApiService) PackagesListPackagesForUserExecute(r ApiPackagesListPackagesForUserRequest) ([]ModelPackage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ModelPackage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesListPackagesForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageType == nil {
		return localVarReturnValue, nil, reportError("packageType is required and must be specified")
	}

	localVarQueryParams.Add("package_type", parameterToString(*r.packageType, ""))
	if r.visibility != nil {
		localVarQueryParams.Add("visibility", parameterToString(*r.visibility, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	token *string
}

// package token
func (r ApiPackagesRestorePackageForAuthenticatedUserRequest) Token(token string) ApiPackagesRestorePackageForAuthenticatedUserRequest {
	r.token = &token
	return r
}

func (r ApiPackagesRestorePackageForAuthenticatedUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageForAuthenticatedUserExecute(r)
}

/*
PackagesRestorePackageForAuthenticatedUser Restore a package for the authenticated user

Restores a package owned by the authenticated user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @return ApiPackagesRestorePackageForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesRestorePackageForAuthenticatedUser(ctx context.Context, packageType string, packageName string) ApiPackagesRestorePackageForAuthenticatedUserRequest {
	return ApiPackagesRestorePackageForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageForAuthenticatedUserExecute(r ApiPackagesRestorePackageForAuthenticatedUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageForAuthenticatedUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageForOrgRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
	token *string
}

// package token
func (r ApiPackagesRestorePackageForOrgRequest) Token(token string) ApiPackagesRestorePackageForOrgRequest {
	r.token = &token
	return r
}

func (r ApiPackagesRestorePackageForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageForOrgExecute(r)
}

/*
PackagesRestorePackageForOrg Restore a package for an organization

Restores an entire package in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @return ApiPackagesRestorePackageForOrgRequest
*/
func (a *PackagesApiService) PackagesRestorePackageForOrg(ctx context.Context, packageType string, packageName string, org string) ApiPackagesRestorePackageForOrgRequest {
	return ApiPackagesRestorePackageForOrgRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageForOrgExecute(r ApiPackagesRestorePackageForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
	token *string
}

// package token
func (r ApiPackagesRestorePackageForUserRequest) Token(token string) ApiPackagesRestorePackageForUserRequest {
	r.token = &token
	return r
}

func (r ApiPackagesRestorePackageForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageForUserExecute(r)
}

/*
PackagesRestorePackageForUser Restore a package for a user

Restores an entire package for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @return ApiPackagesRestorePackageForUserRequest
*/
func (a *PackagesApiService) PackagesRestorePackageForUser(ctx context.Context, packageType string, packageName string, username string) ApiPackagesRestorePackageForUserRequest {
	return ApiPackagesRestorePackageForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageForUserExecute(r ApiPackagesRestorePackageForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageVersionForAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	packageVersionId int32
}

func (r ApiPackagesRestorePackageVersionForAuthenticatedUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageVersionForAuthenticatedUserExecute(r)
}

/*
PackagesRestorePackageVersionForAuthenticatedUser Restore a package version for the authenticated user

Restores a package version owned by the authenticated user.

You can restore a deleted package version under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. If `package_type` is not `container`, your token must also include the `repo` scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesRestorePackageVersionForAuthenticatedUserRequest
*/
func (a *PackagesApiService) PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, packageType string, packageName string, packageVersionId int32) ApiPackagesRestorePackageVersionForAuthenticatedUserRequest {
	return ApiPackagesRestorePackageVersionForAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageVersionForAuthenticatedUserExecute(r ApiPackagesRestorePackageVersionForAuthenticatedUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageVersionForAuthenticatedUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageVersionForOrgRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	org string
	packageVersionId int32
}

func (r ApiPackagesRestorePackageVersionForOrgRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageVersionForOrgExecute(r)
}

/*
PackagesRestorePackageVersionForOrg Restore package version for an organization

Restores a specific package version in an organization.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param org The organization name. The name is not case sensitive.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesRestorePackageVersionForOrgRequest
*/
func (a *PackagesApiService) PackagesRestorePackageVersionForOrg(ctx context.Context, packageType string, packageName string, org string, packageVersionId int32) ApiPackagesRestorePackageVersionForOrgRequest {
	return ApiPackagesRestorePackageVersionForOrgRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		org: org,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageVersionForOrgExecute(r ApiPackagesRestorePackageVersionForOrgRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageVersionForOrg")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPackagesRestorePackageVersionForUserRequest struct {
	ctx context.Context
	ApiService *PackagesApiService
	packageType string
	packageName string
	username string
	packageVersionId int32
}

func (r ApiPackagesRestorePackageVersionForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.PackagesRestorePackageVersionForUserExecute(r)
}

/*
PackagesRestorePackageVersionForUser Restore package version for a user

Restores a specific package version for a user.

You can restore a deleted package under the following conditions:
  - The package was deleted within the last 30 days.
  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.

To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scopes. In addition:
- If `package_type` is not `container`, your token must also include the `repo` scope.
- If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageType The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
 @param packageName The name of the package.
 @param username The handle for the GitHub user account.
 @param packageVersionId Unique identifier of the package version.
 @return ApiPackagesRestorePackageVersionForUserRequest
*/
func (a *PackagesApiService) PackagesRestorePackageVersionForUser(ctx context.Context, packageType string, packageName string, username string, packageVersionId int32) ApiPackagesRestorePackageVersionForUserRequest {
	return ApiPackagesRestorePackageVersionForUserRequest{
		ApiService: a,
		ctx: ctx,
		packageType: packageType,
		packageName: packageName,
		username: username,
		packageVersionId: packageVersionId,
	}
}

// Execute executes the request
func (a *PackagesApiService) PackagesRestorePackageVersionForUserExecute(r ApiPackagesRestorePackageVersionForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesApiService.PackagesRestorePackageVersionForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"package_type"+"}", url.PathEscape(parameterToString(r.packageType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", url.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"package_version_id"+"}", url.PathEscape(parameterToString(r.packageVersionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
