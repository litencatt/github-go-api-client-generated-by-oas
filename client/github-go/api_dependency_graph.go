/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DependencyGraphApiService DependencyGraphApi service
type DependencyGraphApiService service

type ApiDependencyGraphCreateRepositorySnapshotRequest struct {
	ctx context.Context
	ApiService *DependencyGraphApiService
	owner string
	repo string
	snapshot *Snapshot
}

func (r ApiDependencyGraphCreateRepositorySnapshotRequest) Snapshot(snapshot Snapshot) ApiDependencyGraphCreateRepositorySnapshotRequest {
	r.snapshot = &snapshot
	return r
}

func (r ApiDependencyGraphCreateRepositorySnapshotRequest) Execute() (*DependencyGraphCreateRepositorySnapshot201Response, *http.Response, error) {
	return r.ApiService.DependencyGraphCreateRepositorySnapshotExecute(r)
}

/*
DependencyGraphCreateRepositorySnapshot Create a snapshot of dependencies for a repository

Create a new snapshot of a repository's dependencies. You must authenticate using an access token with the `repo` scope to use this endpoint for a repository that the requesting user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiDependencyGraphCreateRepositorySnapshotRequest
*/
func (a *DependencyGraphApiService) DependencyGraphCreateRepositorySnapshot(ctx context.Context, owner string, repo string) ApiDependencyGraphCreateRepositorySnapshotRequest {
	return ApiDependencyGraphCreateRepositorySnapshotRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return DependencyGraphCreateRepositorySnapshot201Response
func (a *DependencyGraphApiService) DependencyGraphCreateRepositorySnapshotExecute(r ApiDependencyGraphCreateRepositorySnapshotRequest) (*DependencyGraphCreateRepositorySnapshot201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependencyGraphCreateRepositorySnapshot201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependencyGraphApiService.DependencyGraphCreateRepositorySnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependency-graph/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.snapshot == nil {
		return localVarReturnValue, nil, reportError("snapshot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.snapshot
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependencyGraphDiffRangeRequest struct {
	ctx context.Context
	ApiService *DependencyGraphApiService
	owner string
	repo string
	basehead string
	name *string
}

// The full path, relative to the repository root, of the dependency manifest file.
func (r ApiDependencyGraphDiffRangeRequest) Name(name string) ApiDependencyGraphDiffRangeRequest {
	r.name = &name
	return r
}

func (r ApiDependencyGraphDiffRangeRequest) Execute() ([]DependencyGraphDiffInner, *http.Response, error) {
	return r.ApiService.DependencyGraphDiffRangeExecute(r)
}

/*
DependencyGraphDiffRange Get a diff of the dependencies between commits

Gets the diff of the dependency changes between two commits of a repository, based on the changes to the dependency manifests made in those commits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param basehead The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions will be resolved to their corresponding HEAD commits, and an appropriate merge base will be determined. This parameter expects the format `{base}...{head}`.
 @return ApiDependencyGraphDiffRangeRequest
*/
func (a *DependencyGraphApiService) DependencyGraphDiffRange(ctx context.Context, owner string, repo string, basehead string) ApiDependencyGraphDiffRangeRequest {
	return ApiDependencyGraphDiffRangeRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		basehead: basehead,
	}
}

// Execute executes the request
//  @return []DependencyGraphDiffInner
func (a *DependencyGraphApiService) DependencyGraphDiffRangeExecute(r ApiDependencyGraphDiffRangeRequest) ([]DependencyGraphDiffInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DependencyGraphDiffInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependencyGraphApiService.DependencyGraphDiffRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"basehead"+"}", url.PathEscape(parameterToString(r.basehead, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
