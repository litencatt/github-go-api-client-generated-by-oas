/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// DependabotApiService DependabotApi service
type DependabotApiService service

type ApiDependabotAddSelectedRepoToOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
	repositoryId int32
}

func (r ApiDependabotAddSelectedRepoToOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DependabotAddSelectedRepoToOrgSecretExecute(r)
}

/*
DependabotAddSelectedRepoToOrgSecret Add selected repository to an organization secret

Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @param repositoryId
 @return ApiDependabotAddSelectedRepoToOrgSecretRequest
*/
func (a *DependabotApiService) DependabotAddSelectedRepoToOrgSecret(ctx context.Context, org string, secretName string, repositoryId int32) ApiDependabotAddSelectedRepoToOrgSecretRequest {
	return ApiDependabotAddSelectedRepoToOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *DependabotApiService) DependabotAddSelectedRepoToOrgSecretExecute(r ApiDependabotAddSelectedRepoToOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotAddSelectedRepoToOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDependabotCreateOrUpdateOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
	dependabotCreateOrUpdateOrgSecretRequest *DependabotCreateOrUpdateOrgSecretRequest
}

func (r ApiDependabotCreateOrUpdateOrgSecretRequest) DependabotCreateOrUpdateOrgSecretRequest(dependabotCreateOrUpdateOrgSecretRequest DependabotCreateOrUpdateOrgSecretRequest) ApiDependabotCreateOrUpdateOrgSecretRequest {
	r.dependabotCreateOrUpdateOrgSecretRequest = &dependabotCreateOrUpdateOrgSecretRequest
	return r
}

func (r ApiDependabotCreateOrUpdateOrgSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DependabotCreateOrUpdateOrgSecretExecute(r)
}

/*
DependabotCreateOrUpdateOrgSecret Create or update an organization secret

Creates or updates an organization secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization
permission to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotCreateOrUpdateOrgSecretRequest
*/
func (a *DependabotApiService) DependabotCreateOrUpdateOrgSecret(ctx context.Context, org string, secretName string) ApiDependabotCreateOrUpdateOrgSecretRequest {
	return ApiDependabotCreateOrUpdateOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DependabotApiService) DependabotCreateOrUpdateOrgSecretExecute(r ApiDependabotCreateOrUpdateOrgSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotCreateOrUpdateOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dependabotCreateOrUpdateOrgSecretRequest == nil {
		return localVarReturnValue, nil, reportError("dependabotCreateOrUpdateOrgSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dependabotCreateOrUpdateOrgSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotCreateOrUpdateRepoSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	owner string
	repo string
	secretName string
	dependabotCreateOrUpdateRepoSecretRequest *DependabotCreateOrUpdateRepoSecretRequest
}

func (r ApiDependabotCreateOrUpdateRepoSecretRequest) DependabotCreateOrUpdateRepoSecretRequest(dependabotCreateOrUpdateRepoSecretRequest DependabotCreateOrUpdateRepoSecretRequest) ApiDependabotCreateOrUpdateRepoSecretRequest {
	r.dependabotCreateOrUpdateRepoSecretRequest = &dependabotCreateOrUpdateRepoSecretRequest
	return r
}

func (r ApiDependabotCreateOrUpdateRepoSecretRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DependabotCreateOrUpdateRepoSecretExecute(r)
}

/*
DependabotCreateOrUpdateRepoSecret Create or update a repository secret

Creates or updates a repository secret with an encrypted value. Encrypt your secret using
[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository
permission to use this endpoint.

#### Example encrypting a secret using Node.js

Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.

```
const sodium = require('tweetsodium');

const key = "base64-encoded-public-key";
const value = "plain-text-secret";

// Convert the message and key to Uint8Array's (Buffer implements that interface)
const messageBytes = Buffer.from(value);
const keyBytes = Buffer.from(key, 'base64');

// Encrypt using LibSodium.
const encryptedBytes = sodium.seal(messageBytes, keyBytes);

// Base64 the encrypted secret
const encrypted = Buffer.from(encryptedBytes).toString('base64');

console.log(encrypted);
```


#### Example encrypting a secret using Python

Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.

```
from base64 import b64encode
from nacl import encoding, public

def encrypt(public_key: str, secret_value: str) -> str:
  """Encrypt a Unicode string using the public key."""
  public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
  sealed_box = public.SealedBox(public_key)
  encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
  return b64encode(encrypted).decode("utf-8")
```

#### Example encrypting a secret using C#

Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.

```
var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");

var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);

Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
```

#### Example encrypting a secret using Ruby

Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.

```ruby
require "rbnacl"
require "base64"

key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
public_key = RbNaCl::PublicKey.new(key)

box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
encrypted_secret = box.encrypt("my_secret")

# Print the base64 encoded secret
puts Base64.strict_encode64(encrypted_secret)
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotCreateOrUpdateRepoSecretRequest
*/
func (a *DependabotApiService) DependabotCreateOrUpdateRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiDependabotCreateOrUpdateRepoSecretRequest {
	return ApiDependabotCreateOrUpdateRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DependabotApiService) DependabotCreateOrUpdateRepoSecretExecute(r ApiDependabotCreateOrUpdateRepoSecretRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotCreateOrUpdateRepoSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dependabotCreateOrUpdateRepoSecretRequest == nil {
		return localVarReturnValue, nil, reportError("dependabotCreateOrUpdateRepoSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dependabotCreateOrUpdateRepoSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotDeleteOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
}

func (r ApiDependabotDeleteOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DependabotDeleteOrgSecretExecute(r)
}

/*
DependabotDeleteOrgSecret Delete an organization secret

Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotDeleteOrgSecretRequest
*/
func (a *DependabotApiService) DependabotDeleteOrgSecret(ctx context.Context, org string, secretName string) ApiDependabotDeleteOrgSecretRequest {
	return ApiDependabotDeleteOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *DependabotApiService) DependabotDeleteOrgSecretExecute(r ApiDependabotDeleteOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotDeleteOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDependabotDeleteRepoSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	owner string
	repo string
	secretName string
}

func (r ApiDependabotDeleteRepoSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DependabotDeleteRepoSecretExecute(r)
}

/*
DependabotDeleteRepoSecret Delete a repository secret

Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotDeleteRepoSecretRequest
*/
func (a *DependabotApiService) DependabotDeleteRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiDependabotDeleteRepoSecretRequest {
	return ApiDependabotDeleteRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *DependabotApiService) DependabotDeleteRepoSecretExecute(r ApiDependabotDeleteRepoSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotDeleteRepoSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDependabotGetOrgPublicKeyRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
}

func (r ApiDependabotGetOrgPublicKeyRequest) Execute() (*DependabotPublicKey, *http.Response, error) {
	return r.ApiService.DependabotGetOrgPublicKeyExecute(r)
}

/*
DependabotGetOrgPublicKey Get an organization public key

Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiDependabotGetOrgPublicKeyRequest
*/
func (a *DependabotApiService) DependabotGetOrgPublicKey(ctx context.Context, org string) ApiDependabotGetOrgPublicKeyRequest {
	return ApiDependabotGetOrgPublicKeyRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return DependabotPublicKey
func (a *DependabotApiService) DependabotGetOrgPublicKeyExecute(r ApiDependabotGetOrgPublicKeyRequest) (*DependabotPublicKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependabotPublicKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotGetOrgPublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotGetOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
}

func (r ApiDependabotGetOrgSecretRequest) Execute() (*OrganizationDependabotSecret, *http.Response, error) {
	return r.ApiService.DependabotGetOrgSecretExecute(r)
}

/*
DependabotGetOrgSecret Get an organization secret

Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotGetOrgSecretRequest
*/
func (a *DependabotApiService) DependabotGetOrgSecret(ctx context.Context, org string, secretName string) ApiDependabotGetOrgSecretRequest {
	return ApiDependabotGetOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return OrganizationDependabotSecret
func (a *DependabotApiService) DependabotGetOrgSecretExecute(r ApiDependabotGetOrgSecretRequest) (*OrganizationDependabotSecret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationDependabotSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotGetOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotGetRepoPublicKeyRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	owner string
	repo string
}

func (r ApiDependabotGetRepoPublicKeyRequest) Execute() (*DependabotPublicKey, *http.Response, error) {
	return r.ApiService.DependabotGetRepoPublicKeyExecute(r)
}

/*
DependabotGetRepoPublicKey Get a repository public key

Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiDependabotGetRepoPublicKeyRequest
*/
func (a *DependabotApiService) DependabotGetRepoPublicKey(ctx context.Context, owner string, repo string) ApiDependabotGetRepoPublicKeyRequest {
	return ApiDependabotGetRepoPublicKeyRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return DependabotPublicKey
func (a *DependabotApiService) DependabotGetRepoPublicKeyExecute(r ApiDependabotGetRepoPublicKeyRequest) (*DependabotPublicKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependabotPublicKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotGetRepoPublicKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependabot/secrets/public-key"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotGetRepoSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	owner string
	repo string
	secretName string
}

func (r ApiDependabotGetRepoSecretRequest) Execute() (*DependabotSecret, *http.Response, error) {
	return r.ApiService.DependabotGetRepoSecretExecute(r)
}

/*
DependabotGetRepoSecret Get a repository secret

Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotGetRepoSecretRequest
*/
func (a *DependabotApiService) DependabotGetRepoSecret(ctx context.Context, owner string, repo string, secretName string) ApiDependabotGetRepoSecretRequest {
	return ApiDependabotGetRepoSecretRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return DependabotSecret
func (a *DependabotApiService) DependabotGetRepoSecretExecute(r ApiDependabotGetRepoSecretRequest) (*DependabotSecret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependabotSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotGetRepoSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotListOrgSecretsRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiDependabotListOrgSecretsRequest) PerPage(perPage int32) ApiDependabotListOrgSecretsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiDependabotListOrgSecretsRequest) Page(page int32) ApiDependabotListOrgSecretsRequest {
	r.page = &page
	return r
}

func (r ApiDependabotListOrgSecretsRequest) Execute() (*DependabotListOrgSecrets200Response, *http.Response, error) {
	return r.ApiService.DependabotListOrgSecretsExecute(r)
}

/*
DependabotListOrgSecrets List organization secrets

Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @return ApiDependabotListOrgSecretsRequest
*/
func (a *DependabotApiService) DependabotListOrgSecrets(ctx context.Context, org string) ApiDependabotListOrgSecretsRequest {
	return ApiDependabotListOrgSecretsRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return DependabotListOrgSecrets200Response
func (a *DependabotApiService) DependabotListOrgSecretsExecute(r ApiDependabotListOrgSecretsRequest) (*DependabotListOrgSecrets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependabotListOrgSecrets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotListOrgSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotListRepoSecretsRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	owner string
	repo string
	perPage *int32
	page *int32
}

// The number of results per page (max 100).
func (r ApiDependabotListRepoSecretsRequest) PerPage(perPage int32) ApiDependabotListRepoSecretsRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiDependabotListRepoSecretsRequest) Page(page int32) ApiDependabotListRepoSecretsRequest {
	r.page = &page
	return r
}

func (r ApiDependabotListRepoSecretsRequest) Execute() (*DependabotListRepoSecrets200Response, *http.Response, error) {
	return r.ApiService.DependabotListRepoSecretsExecute(r)
}

/*
DependabotListRepoSecrets List repository secrets

Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @return ApiDependabotListRepoSecretsRequest
*/
func (a *DependabotApiService) DependabotListRepoSecrets(ctx context.Context, owner string, repo string) ApiDependabotListRepoSecretsRequest {
	return ApiDependabotListRepoSecretsRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
	}
}

// Execute executes the request
//  @return DependabotListRepoSecrets200Response
func (a *DependabotApiService) DependabotListRepoSecretsExecute(r ApiDependabotListRepoSecretsRequest) (*DependabotListRepoSecrets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependabotListRepoSecrets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotListRepoSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/dependabot/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotListSelectedReposForOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
	page *int32
	perPage *int32
}

// Page number of the results to fetch.
func (r ApiDependabotListSelectedReposForOrgSecretRequest) Page(page int32) ApiDependabotListSelectedReposForOrgSecretRequest {
	r.page = &page
	return r
}

// The number of results per page (max 100).
func (r ApiDependabotListSelectedReposForOrgSecretRequest) PerPage(perPage int32) ApiDependabotListSelectedReposForOrgSecretRequest {
	r.perPage = &perPage
	return r
}

func (r ApiDependabotListSelectedReposForOrgSecretRequest) Execute() (*ActionsListSelectedReposForOrgSecret200Response, *http.Response, error) {
	return r.ApiService.DependabotListSelectedReposForOrgSecretExecute(r)
}

/*
DependabotListSelectedReposForOrgSecret List selected repositories for an organization secret

Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotListSelectedReposForOrgSecretRequest
*/
func (a *DependabotApiService) DependabotListSelectedReposForOrgSecret(ctx context.Context, org string, secretName string) ApiDependabotListSelectedReposForOrgSecretRequest {
	return ApiDependabotListSelectedReposForOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
//  @return ActionsListSelectedReposForOrgSecret200Response
func (a *DependabotApiService) DependabotListSelectedReposForOrgSecretExecute(r ApiDependabotListSelectedReposForOrgSecretRequest) (*ActionsListSelectedReposForOrgSecret200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsListSelectedReposForOrgSecret200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotListSelectedReposForOrgSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDependabotRemoveSelectedRepoFromOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
	repositoryId int32
}

func (r ApiDependabotRemoveSelectedRepoFromOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DependabotRemoveSelectedRepoFromOrgSecretExecute(r)
}

/*
DependabotRemoveSelectedRepoFromOrgSecret Remove selected repository from an organization secret

Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @param repositoryId
 @return ApiDependabotRemoveSelectedRepoFromOrgSecretRequest
*/
func (a *DependabotApiService) DependabotRemoveSelectedRepoFromOrgSecret(ctx context.Context, org string, secretName string, repositoryId int32) ApiDependabotRemoveSelectedRepoFromOrgSecretRequest {
	return ApiDependabotRemoveSelectedRepoFromOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *DependabotApiService) DependabotRemoveSelectedRepoFromOrgSecretExecute(r ApiDependabotRemoveSelectedRepoFromOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotRemoveSelectedRepoFromOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterToString(r.repositoryId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDependabotSetSelectedReposForOrgSecretRequest struct {
	ctx context.Context
	ApiService *DependabotApiService
	org string
	secretName string
	dependabotSetSelectedReposForOrgSecretRequest *DependabotSetSelectedReposForOrgSecretRequest
}

func (r ApiDependabotSetSelectedReposForOrgSecretRequest) DependabotSetSelectedReposForOrgSecretRequest(dependabotSetSelectedReposForOrgSecretRequest DependabotSetSelectedReposForOrgSecretRequest) ApiDependabotSetSelectedReposForOrgSecretRequest {
	r.dependabotSetSelectedReposForOrgSecretRequest = &dependabotSetSelectedReposForOrgSecretRequest
	return r
}

func (r ApiDependabotSetSelectedReposForOrgSecretRequest) Execute() (*http.Response, error) {
	return r.ApiService.DependabotSetSelectedReposForOrgSecretExecute(r)
}

/*
DependabotSetSelectedReposForOrgSecret Set selected repositories for an organization secret

Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param secretName The name of the secret.
 @return ApiDependabotSetSelectedReposForOrgSecretRequest
*/
func (a *DependabotApiService) DependabotSetSelectedReposForOrgSecret(ctx context.Context, org string, secretName string) ApiDependabotSetSelectedReposForOrgSecretRequest {
	return ApiDependabotSetSelectedReposForOrgSecretRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		secretName: secretName,
	}
}

// Execute executes the request
func (a *DependabotApiService) DependabotSetSelectedReposForOrgSecretExecute(r ApiDependabotSetSelectedReposForOrgSecretRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DependabotApiService.DependabotSetSelectedReposForOrgSecret")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"secret_name"+"}", url.PathEscape(parameterToString(r.secretName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dependabotSetSelectedReposForOrgSecretRequest == nil {
		return nil, reportError("dependabotSetSelectedReposForOrgSecretRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dependabotSetSelectedReposForOrgSecretRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
