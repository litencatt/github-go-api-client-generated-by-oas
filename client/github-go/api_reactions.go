/*
GitHub v3 REST API

GitHub's v3 REST API.

API version: 1.1.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ReactionsApiService ReactionsApi service
type ReactionsApiService service

type ApiReactionsCreateForCommitCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionsCreateForCommitCommentRequest *ReactionsCreateForCommitCommentRequest
}

func (r ApiReactionsCreateForCommitCommentRequest) ReactionsCreateForCommitCommentRequest(reactionsCreateForCommitCommentRequest ReactionsCreateForCommitCommentRequest) ApiReactionsCreateForCommitCommentRequest {
	r.reactionsCreateForCommitCommentRequest = &reactionsCreateForCommitCommentRequest
	return r
}

func (r ApiReactionsCreateForCommitCommentRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForCommitCommentExecute(r)
}

/*
ReactionsCreateForCommitComment Create reaction for a commit comment

Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsCreateForCommitCommentRequest
*/
func (a *ReactionsApiService) ReactionsCreateForCommitComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsCreateForCommitCommentRequest {
	return ApiReactionsCreateForCommitCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForCommitCommentExecute(r ApiReactionsCreateForCommitCommentRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForCommitComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForCommitCommentRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForCommitCommentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForCommitCommentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForIssueRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	issueNumber int32
	reactionsCreateForIssueRequest *ReactionsCreateForIssueRequest
}

func (r ApiReactionsCreateForIssueRequest) ReactionsCreateForIssueRequest(reactionsCreateForIssueRequest ReactionsCreateForIssueRequest) ApiReactionsCreateForIssueRequest {
	r.reactionsCreateForIssueRequest = &reactionsCreateForIssueRequest
	return r
}

func (r ApiReactionsCreateForIssueRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForIssueExecute(r)
}

/*
ReactionsCreateForIssue Create reaction for an issue

Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param issueNumber The number that identifies the issue.
 @return ApiReactionsCreateForIssueRequest
*/
func (a *ReactionsApiService) ReactionsCreateForIssue(ctx context.Context, owner string, repo string, issueNumber int32) ApiReactionsCreateForIssueRequest {
	return ApiReactionsCreateForIssueRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		issueNumber: issueNumber,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForIssueExecute(r ApiReactionsCreateForIssueRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForIssue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_number"+"}", url.PathEscape(parameterToString(r.issueNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForIssueRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForIssueRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForIssueRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForIssueCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionsCreateForIssueCommentRequest *ReactionsCreateForIssueCommentRequest
}

func (r ApiReactionsCreateForIssueCommentRequest) ReactionsCreateForIssueCommentRequest(reactionsCreateForIssueCommentRequest ReactionsCreateForIssueCommentRequest) ApiReactionsCreateForIssueCommentRequest {
	r.reactionsCreateForIssueCommentRequest = &reactionsCreateForIssueCommentRequest
	return r
}

func (r ApiReactionsCreateForIssueCommentRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForIssueCommentExecute(r)
}

/*
ReactionsCreateForIssueComment Create reaction for an issue comment

Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsCreateForIssueCommentRequest
*/
func (a *ReactionsApiService) ReactionsCreateForIssueComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsCreateForIssueCommentRequest {
	return ApiReactionsCreateForIssueCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForIssueCommentExecute(r ApiReactionsCreateForIssueCommentRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForIssueComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForIssueCommentRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForIssueCommentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForIssueCommentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForPullRequestReviewCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionsCreateForPullRequestReviewCommentRequest *ReactionsCreateForPullRequestReviewCommentRequest
}

func (r ApiReactionsCreateForPullRequestReviewCommentRequest) ReactionsCreateForPullRequestReviewCommentRequest(reactionsCreateForPullRequestReviewCommentRequest ReactionsCreateForPullRequestReviewCommentRequest) ApiReactionsCreateForPullRequestReviewCommentRequest {
	r.reactionsCreateForPullRequestReviewCommentRequest = &reactionsCreateForPullRequestReviewCommentRequest
	return r
}

func (r ApiReactionsCreateForPullRequestReviewCommentRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForPullRequestReviewCommentExecute(r)
}

/*
ReactionsCreateForPullRequestReviewComment Create reaction for a pull request review comment

Create a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsCreateForPullRequestReviewCommentRequest
*/
func (a *ReactionsApiService) ReactionsCreateForPullRequestReviewComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsCreateForPullRequestReviewCommentRequest {
	return ApiReactionsCreateForPullRequestReviewCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForPullRequestReviewCommentExecute(r ApiReactionsCreateForPullRequestReviewCommentRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForPullRequestReviewComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForPullRequestReviewCommentRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForPullRequestReviewCommentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForPullRequestReviewCommentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForReleaseRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	releaseId int32
	reactionsCreateForReleaseRequest *ReactionsCreateForReleaseRequest
}

func (r ApiReactionsCreateForReleaseRequest) ReactionsCreateForReleaseRequest(reactionsCreateForReleaseRequest ReactionsCreateForReleaseRequest) ApiReactionsCreateForReleaseRequest {
	r.reactionsCreateForReleaseRequest = &reactionsCreateForReleaseRequest
	return r
}

func (r ApiReactionsCreateForReleaseRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForReleaseExecute(r)
}

/*
ReactionsCreateForRelease Create reaction for a release

Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param releaseId The unique identifier of the release.
 @return ApiReactionsCreateForReleaseRequest
*/
func (a *ReactionsApiService) ReactionsCreateForRelease(ctx context.Context, owner string, repo string, releaseId int32) ApiReactionsCreateForReleaseRequest {
	return ApiReactionsCreateForReleaseRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		releaseId: releaseId,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForReleaseExecute(r ApiReactionsCreateForReleaseRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForRelease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/releases/{release_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"release_id"+"}", url.PathEscape(parameterToString(r.releaseId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForReleaseRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForReleaseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForReleaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForTeamDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
	reactionsCreateForTeamDiscussionCommentInOrgRequest *ReactionsCreateForTeamDiscussionCommentInOrgRequest
}

func (r ApiReactionsCreateForTeamDiscussionCommentInOrgRequest) ReactionsCreateForTeamDiscussionCommentInOrgRequest(reactionsCreateForTeamDiscussionCommentInOrgRequest ReactionsCreateForTeamDiscussionCommentInOrgRequest) ApiReactionsCreateForTeamDiscussionCommentInOrgRequest {
	r.reactionsCreateForTeamDiscussionCommentInOrgRequest = &reactionsCreateForTeamDiscussionCommentInOrgRequest
	return r
}

func (r ApiReactionsCreateForTeamDiscussionCommentInOrgRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForTeamDiscussionCommentInOrgExecute(r)
}

/*
ReactionsCreateForTeamDiscussionCommentInOrg Create reaction for a team discussion comment

Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiReactionsCreateForTeamDiscussionCommentInOrgRequest
*/
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32) ApiReactionsCreateForTeamDiscussionCommentInOrgRequest {
	return ApiReactionsCreateForTeamDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionCommentInOrgExecute(r ApiReactionsCreateForTeamDiscussionCommentInOrgRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForTeamDiscussionCommentInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForTeamDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForTeamDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForTeamDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForTeamDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	teamId int32
	discussionNumber int32
	commentNumber int32
	reactionsCreateForTeamDiscussionCommentInOrgRequest *ReactionsCreateForTeamDiscussionCommentInOrgRequest
}

func (r ApiReactionsCreateForTeamDiscussionCommentLegacyRequest) ReactionsCreateForTeamDiscussionCommentInOrgRequest(reactionsCreateForTeamDiscussionCommentInOrgRequest ReactionsCreateForTeamDiscussionCommentInOrgRequest) ApiReactionsCreateForTeamDiscussionCommentLegacyRequest {
	r.reactionsCreateForTeamDiscussionCommentInOrgRequest = &reactionsCreateForTeamDiscussionCommentInOrgRequest
	return r
}

func (r ApiReactionsCreateForTeamDiscussionCommentLegacyRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForTeamDiscussionCommentLegacyExecute(r)
}

/*
ReactionsCreateForTeamDiscussionCommentLegacy Create reaction for a team discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.

Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiReactionsCreateForTeamDiscussionCommentLegacyRequest

Deprecated
*/
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32, commentNumber int32) ApiReactionsCreateForTeamDiscussionCommentLegacyRequest {
	return ApiReactionsCreateForTeamDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return Reaction
// Deprecated
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionCommentLegacyExecute(r ApiReactionsCreateForTeamDiscussionCommentLegacyRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForTeamDiscussionCommentLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForTeamDiscussionCommentInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForTeamDiscussionCommentInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForTeamDiscussionCommentInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForTeamDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	reactionsCreateForTeamDiscussionInOrgRequest *ReactionsCreateForTeamDiscussionInOrgRequest
}

func (r ApiReactionsCreateForTeamDiscussionInOrgRequest) ReactionsCreateForTeamDiscussionInOrgRequest(reactionsCreateForTeamDiscussionInOrgRequest ReactionsCreateForTeamDiscussionInOrgRequest) ApiReactionsCreateForTeamDiscussionInOrgRequest {
	r.reactionsCreateForTeamDiscussionInOrgRequest = &reactionsCreateForTeamDiscussionInOrgRequest
	return r
}

func (r ApiReactionsCreateForTeamDiscussionInOrgRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForTeamDiscussionInOrgExecute(r)
}

/*
ReactionsCreateForTeamDiscussionInOrg Create reaction for a team discussion

Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.

**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiReactionsCreateForTeamDiscussionInOrgRequest
*/
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiReactionsCreateForTeamDiscussionInOrgRequest {
	return ApiReactionsCreateForTeamDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return Reaction
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionInOrgExecute(r ApiReactionsCreateForTeamDiscussionInOrgRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForTeamDiscussionInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForTeamDiscussionInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForTeamDiscussionInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForTeamDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsCreateForTeamDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	teamId int32
	discussionNumber int32
	reactionsCreateForTeamDiscussionInOrgRequest *ReactionsCreateForTeamDiscussionInOrgRequest
}

func (r ApiReactionsCreateForTeamDiscussionLegacyRequest) ReactionsCreateForTeamDiscussionInOrgRequest(reactionsCreateForTeamDiscussionInOrgRequest ReactionsCreateForTeamDiscussionInOrgRequest) ApiReactionsCreateForTeamDiscussionLegacyRequest {
	r.reactionsCreateForTeamDiscussionInOrgRequest = &reactionsCreateForTeamDiscussionInOrgRequest
	return r
}

func (r ApiReactionsCreateForTeamDiscussionLegacyRequest) Execute() (*Reaction, *http.Response, error) {
	return r.ApiService.ReactionsCreateForTeamDiscussionLegacyExecute(r)
}

/*
ReactionsCreateForTeamDiscussionLegacy Create reaction for a team discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.

Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiReactionsCreateForTeamDiscussionLegacyRequest

Deprecated
*/
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiReactionsCreateForTeamDiscussionLegacyRequest {
	return ApiReactionsCreateForTeamDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return Reaction
// Deprecated
func (a *ReactionsApiService) ReactionsCreateForTeamDiscussionLegacyExecute(r ApiReactionsCreateForTeamDiscussionLegacyRequest) (*Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsCreateForTeamDiscussionLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reactionsCreateForTeamDiscussionInOrgRequest == nil {
		return localVarReturnValue, nil, reportError("reactionsCreateForTeamDiscussionInOrgRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reactionsCreateForTeamDiscussionInOrgRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsDeleteForCommitCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionId int32
}

func (r ApiReactionsDeleteForCommitCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForCommitCommentExecute(r)
}

/*
ReactionsDeleteForCommitComment Delete a commit comment reaction

**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForCommitCommentRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForCommitComment(ctx context.Context, owner string, repo string, commentId int32, reactionId int32) ApiReactionsDeleteForCommitCommentRequest {
	return ApiReactionsDeleteForCommitCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForCommitCommentExecute(r ApiReactionsDeleteForCommitCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForCommitComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForIssueRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	issueNumber int32
	reactionId int32
}

func (r ApiReactionsDeleteForIssueRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForIssueExecute(r)
}

/*
ReactionsDeleteForIssue Delete an issue reaction

**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.

Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param issueNumber The number that identifies the issue.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForIssueRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForIssue(ctx context.Context, owner string, repo string, issueNumber int32, reactionId int32) ApiReactionsDeleteForIssueRequest {
	return ApiReactionsDeleteForIssueRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		issueNumber: issueNumber,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForIssueExecute(r ApiReactionsDeleteForIssueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForIssue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_number"+"}", url.PathEscape(parameterToString(r.issueNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForIssueCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionId int32
}

func (r ApiReactionsDeleteForIssueCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForIssueCommentExecute(r)
}

/*
ReactionsDeleteForIssueComment Delete an issue comment reaction

**Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.

Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForIssueCommentRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForIssueComment(ctx context.Context, owner string, repo string, commentId int32, reactionId int32) ApiReactionsDeleteForIssueCommentRequest {
	return ApiReactionsDeleteForIssueCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForIssueCommentExecute(r ApiReactionsDeleteForIssueCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForIssueComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForPullRequestCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	reactionId int32
}

func (r ApiReactionsDeleteForPullRequestCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForPullRequestCommentExecute(r)
}

/*
ReactionsDeleteForPullRequestComment Delete a pull request comment reaction

**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`

Delete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForPullRequestCommentRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForPullRequestComment(ctx context.Context, owner string, repo string, commentId int32, reactionId int32) ApiReactionsDeleteForPullRequestCommentRequest {
	return ApiReactionsDeleteForPullRequestCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForPullRequestCommentExecute(r ApiReactionsDeleteForPullRequestCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForPullRequestComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForReleaseRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	releaseId int32
	reactionId int32
}

func (r ApiReactionsDeleteForReleaseRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForReleaseExecute(r)
}

/*
ReactionsDeleteForRelease Delete a release reaction

**Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.

Delete a reaction to a [release](https://docs.github.com/rest/reference/repos#releases).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param releaseId The unique identifier of the release.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForReleaseRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForRelease(ctx context.Context, owner string, repo string, releaseId int32, reactionId int32) ApiReactionsDeleteForReleaseRequest {
	return ApiReactionsDeleteForReleaseRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		releaseId: releaseId,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForReleaseExecute(r ApiReactionsDeleteForReleaseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForRelease")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"release_id"+"}", url.PathEscape(parameterToString(r.releaseId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForTeamDiscussionRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	reactionId int32
}

func (r ApiReactionsDeleteForTeamDiscussionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForTeamDiscussionExecute(r)
}

/*
ReactionsDeleteForTeamDiscussion Delete team discussion reaction

**Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForTeamDiscussionRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForTeamDiscussion(ctx context.Context, org string, teamSlug string, discussionNumber int32, reactionId int32) ApiReactionsDeleteForTeamDiscussionRequest {
	return ApiReactionsDeleteForTeamDiscussionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForTeamDiscussionExecute(r ApiReactionsDeleteForTeamDiscussionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForTeamDiscussion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsDeleteForTeamDiscussionCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
	reactionId int32
}

func (r ApiReactionsDeleteForTeamDiscussionCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReactionsDeleteForTeamDiscussionCommentExecute(r)
}

/*
ReactionsDeleteForTeamDiscussionComment Delete team discussion comment reaction

**Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.

Delete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @param reactionId The unique identifier of the reaction.
 @return ApiReactionsDeleteForTeamDiscussionCommentRequest
*/
func (a *ReactionsApiService) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32, reactionId int32) ApiReactionsDeleteForTeamDiscussionCommentRequest {
	return ApiReactionsDeleteForTeamDiscussionCommentRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
		reactionId: reactionId,
	}
}

// Execute executes the request
func (a *ReactionsApiService) ReactionsDeleteForTeamDiscussionCommentExecute(r ApiReactionsDeleteForTeamDiscussionCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsDeleteForTeamDiscussionComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reaction_id"+"}", url.PathEscape(parameterToString(r.reactionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReactionsListForCommitCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.
func (r ApiReactionsListForCommitCommentRequest) Content(content string) ApiReactionsListForCommitCommentRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForCommitCommentRequest) PerPage(perPage int32) ApiReactionsListForCommitCommentRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForCommitCommentRequest) Page(page int32) ApiReactionsListForCommitCommentRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForCommitCommentRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForCommitCommentExecute(r)
}

/*
ReactionsListForCommitComment List reactions for a commit comment

List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsListForCommitCommentRequest
*/
func (a *ReactionsApiService) ReactionsListForCommitComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsListForCommitCommentRequest {
	return ApiReactionsListForCommitCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForCommitCommentExecute(r ApiReactionsListForCommitCommentRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForCommitComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForIssueRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	issueNumber int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.
func (r ApiReactionsListForIssueRequest) Content(content string) ApiReactionsListForIssueRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForIssueRequest) PerPage(perPage int32) ApiReactionsListForIssueRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForIssueRequest) Page(page int32) ApiReactionsListForIssueRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForIssueRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForIssueExecute(r)
}

/*
ReactionsListForIssue List reactions for an issue

List the reactions to an [issue](https://docs.github.com/rest/reference/issues).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param issueNumber The number that identifies the issue.
 @return ApiReactionsListForIssueRequest
*/
func (a *ReactionsApiService) ReactionsListForIssue(ctx context.Context, owner string, repo string, issueNumber int32) ApiReactionsListForIssueRequest {
	return ApiReactionsListForIssueRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		issueNumber: issueNumber,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForIssueExecute(r ApiReactionsListForIssueRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForIssue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"issue_number"+"}", url.PathEscape(parameterToString(r.issueNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForIssueCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.
func (r ApiReactionsListForIssueCommentRequest) Content(content string) ApiReactionsListForIssueCommentRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForIssueCommentRequest) PerPage(perPage int32) ApiReactionsListForIssueCommentRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForIssueCommentRequest) Page(page int32) ApiReactionsListForIssueCommentRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForIssueCommentRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForIssueCommentExecute(r)
}

/*
ReactionsListForIssueComment List reactions for an issue comment

List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsListForIssueCommentRequest
*/
func (a *ReactionsApiService) ReactionsListForIssueComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsListForIssueCommentRequest {
	return ApiReactionsListForIssueCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForIssueCommentExecute(r ApiReactionsListForIssueCommentRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForIssueComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForPullRequestReviewCommentRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	commentId int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.
func (r ApiReactionsListForPullRequestReviewCommentRequest) Content(content string) ApiReactionsListForPullRequestReviewCommentRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForPullRequestReviewCommentRequest) PerPage(perPage int32) ApiReactionsListForPullRequestReviewCommentRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForPullRequestReviewCommentRequest) Page(page int32) ApiReactionsListForPullRequestReviewCommentRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForPullRequestReviewCommentRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForPullRequestReviewCommentExecute(r)
}

/*
ReactionsListForPullRequestReviewComment List reactions for a pull request review comment

List the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param commentId The unique identifier of the comment.
 @return ApiReactionsListForPullRequestReviewCommentRequest
*/
func (a *ReactionsApiService) ReactionsListForPullRequestReviewComment(ctx context.Context, owner string, repo string, commentId int32) ApiReactionsListForPullRequestReviewCommentRequest {
	return ApiReactionsListForPullRequestReviewCommentRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForPullRequestReviewCommentExecute(r ApiReactionsListForPullRequestReviewCommentRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForPullRequestReviewComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForReleaseRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	owner string
	repo string
	releaseId int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a release.
func (r ApiReactionsListForReleaseRequest) Content(content string) ApiReactionsListForReleaseRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForReleaseRequest) PerPage(perPage int32) ApiReactionsListForReleaseRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForReleaseRequest) Page(page int32) ApiReactionsListForReleaseRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForReleaseRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForReleaseExecute(r)
}

/*
ReactionsListForRelease List reactions for a release

List the reactions to a [release](https://docs.github.com/rest/reference/repos#releases).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param owner The account owner of the repository. The name is not case sensitive.
 @param repo The name of the repository. The name is not case sensitive.
 @param releaseId The unique identifier of the release.
 @return ApiReactionsListForReleaseRequest
*/
func (a *ReactionsApiService) ReactionsListForRelease(ctx context.Context, owner string, repo string, releaseId int32) ApiReactionsListForReleaseRequest {
	return ApiReactionsListForReleaseRequest{
		ApiService: a,
		ctx: ctx,
		owner: owner,
		repo: repo,
		releaseId: releaseId,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForReleaseExecute(r ApiReactionsListForReleaseRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForRelease")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{owner}/{repo}/releases/{release_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", url.PathEscape(parameterToString(r.owner, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", url.PathEscape(parameterToString(r.repo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"release_id"+"}", url.PathEscape(parameterToString(r.releaseId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v BasicError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForTeamDiscussionCommentInOrgRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	commentNumber int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
func (r ApiReactionsListForTeamDiscussionCommentInOrgRequest) Content(content string) ApiReactionsListForTeamDiscussionCommentInOrgRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForTeamDiscussionCommentInOrgRequest) PerPage(perPage int32) ApiReactionsListForTeamDiscussionCommentInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForTeamDiscussionCommentInOrgRequest) Page(page int32) ApiReactionsListForTeamDiscussionCommentInOrgRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForTeamDiscussionCommentInOrgRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForTeamDiscussionCommentInOrgExecute(r)
}

/*
ReactionsListForTeamDiscussionCommentInOrg List reactions for a team discussion comment

List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiReactionsListForTeamDiscussionCommentInOrgRequest
*/
func (a *ReactionsApiService) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32, commentNumber int32) ApiReactionsListForTeamDiscussionCommentInOrgRequest {
	return ApiReactionsListForTeamDiscussionCommentInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForTeamDiscussionCommentInOrgExecute(r ApiReactionsListForTeamDiscussionCommentInOrgRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForTeamDiscussionCommentInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForTeamDiscussionCommentLegacyRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	teamId int32
	discussionNumber int32
	commentNumber int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.
func (r ApiReactionsListForTeamDiscussionCommentLegacyRequest) Content(content string) ApiReactionsListForTeamDiscussionCommentLegacyRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForTeamDiscussionCommentLegacyRequest) PerPage(perPage int32) ApiReactionsListForTeamDiscussionCommentLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForTeamDiscussionCommentLegacyRequest) Page(page int32) ApiReactionsListForTeamDiscussionCommentLegacyRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForTeamDiscussionCommentLegacyRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForTeamDiscussionCommentLegacyExecute(r)
}

/*
ReactionsListForTeamDiscussionCommentLegacy List reactions for a team discussion comment (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.

List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @param commentNumber The number that identifies the comment.
 @return ApiReactionsListForTeamDiscussionCommentLegacyRequest

Deprecated
*/
func (a *ReactionsApiService) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, teamId int32, discussionNumber int32, commentNumber int32) ApiReactionsListForTeamDiscussionCommentLegacyRequest {
	return ApiReactionsListForTeamDiscussionCommentLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
	}
}

// Execute executes the request
//  @return []Reaction
// Deprecated
func (a *ReactionsApiService) ReactionsListForTeamDiscussionCommentLegacyExecute(r ApiReactionsListForTeamDiscussionCommentLegacyRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForTeamDiscussionCommentLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_number"+"}", url.PathEscape(parameterToString(r.commentNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForTeamDiscussionInOrgRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	org string
	teamSlug string
	discussionNumber int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
func (r ApiReactionsListForTeamDiscussionInOrgRequest) Content(content string) ApiReactionsListForTeamDiscussionInOrgRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForTeamDiscussionInOrgRequest) PerPage(perPage int32) ApiReactionsListForTeamDiscussionInOrgRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForTeamDiscussionInOrgRequest) Page(page int32) ApiReactionsListForTeamDiscussionInOrgRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForTeamDiscussionInOrgRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForTeamDiscussionInOrgExecute(r)
}

/*
ReactionsListForTeamDiscussionInOrg List reactions for a team discussion

List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org The organization name. The name is not case sensitive.
 @param teamSlug The slug of the team name.
 @param discussionNumber The number that identifies the discussion.
 @return ApiReactionsListForTeamDiscussionInOrgRequest
*/
func (a *ReactionsApiService) ReactionsListForTeamDiscussionInOrg(ctx context.Context, org string, teamSlug string, discussionNumber int32) ApiReactionsListForTeamDiscussionInOrgRequest {
	return ApiReactionsListForTeamDiscussionInOrgRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return []Reaction
func (a *ReactionsApiService) ReactionsListForTeamDiscussionInOrgExecute(r ApiReactionsListForTeamDiscussionInOrgRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForTeamDiscussionInOrg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterToString(r.org, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"team_slug"+"}", url.PathEscape(parameterToString(r.teamSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactionsListForTeamDiscussionLegacyRequest struct {
	ctx context.Context
	ApiService *ReactionsApiService
	teamId int32
	discussionNumber int32
	content *string
	perPage *int32
	page *int32
}

// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.
func (r ApiReactionsListForTeamDiscussionLegacyRequest) Content(content string) ApiReactionsListForTeamDiscussionLegacyRequest {
	r.content = &content
	return r
}

// The number of results per page (max 100).
func (r ApiReactionsListForTeamDiscussionLegacyRequest) PerPage(perPage int32) ApiReactionsListForTeamDiscussionLegacyRequest {
	r.perPage = &perPage
	return r
}

// Page number of the results to fetch.
func (r ApiReactionsListForTeamDiscussionLegacyRequest) Page(page int32) ApiReactionsListForTeamDiscussionLegacyRequest {
	r.page = &page
	return r
}

func (r ApiReactionsListForTeamDiscussionLegacyRequest) Execute() ([]Reaction, *http.Response, error) {
	return r.ApiService.ReactionsListForTeamDiscussionLegacyExecute(r)
}

/*
ReactionsListForTeamDiscussionLegacy List reactions for a team discussion (Legacy)

**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.

List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param teamId The unique identifier of the team.
 @param discussionNumber The number that identifies the discussion.
 @return ApiReactionsListForTeamDiscussionLegacyRequest

Deprecated
*/
func (a *ReactionsApiService) ReactionsListForTeamDiscussionLegacy(ctx context.Context, teamId int32, discussionNumber int32) ApiReactionsListForTeamDiscussionLegacyRequest {
	return ApiReactionsListForTeamDiscussionLegacyRequest{
		ApiService: a,
		ctx: ctx,
		teamId: teamId,
		discussionNumber: discussionNumber,
	}
}

// Execute executes the request
//  @return []Reaction
// Deprecated
func (a *ReactionsApiService) ReactionsListForTeamDiscussionLegacyExecute(r ApiReactionsListForTeamDiscussionLegacyRequest) ([]Reaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Reaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsApiService.ReactionsListForTeamDiscussionLegacy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{team_id}/discussions/{discussion_number}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"team_id"+"}", url.PathEscape(parameterToString(r.teamId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"discussion_number"+"}", url.PathEscape(parameterToString(r.discussionNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
